<doc>
  <assembly>
    <name>ILNumerics.Computing</name>
  </assembly>
  <members>
    <member name="T:ILNumerics.ILMath">
      <summary>
            Main math class, exposes static array functions. Import all methods from this class by adding "using static ILNumerics.ILMath;" (C#) to gain access to all functions without the class qualifier.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.Int64})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.Int32})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.Int16})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.SByte})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.Single})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.abs(ILNumerics.BaseArray{System.Double})">
      <summary>
Absolute values of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Absolute values of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Computes angles for cosine array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Computes angles for cosine array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:ILNumerics.complex.Acos(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.BaseArray{System.Single})">
      <summary>
Computes angles for cosine array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:System.Math.Acos(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.acos(ILNumerics.BaseArray{System.Double})">
      <summary>
Computes angles for cosine array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Returns the angles whose cosine corresponds to the input array elements. See: <see cref="M:System.Math.Acos(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Add.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
Binary broadcasting operation: Add.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.add_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
Binary broadcasting operation: Add, saturating.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Boolean},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are true.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.all(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
Determines whether all elements of <paramref name="A" /> along the given dimension <paramref name="dim" /> are 'not zero'.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Double})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Single})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.allall(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Tests if all elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for all elements of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed and elements of the input array <paramref name="A" /> are not iterated if the number of Trues are known for the logical input.</para>
        <para>If elements must be iterated the operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.and(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Elementwise 'And' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Boolean},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is true.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.any(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
Determines whether any element of <paramref name="A" /> along the given dimension <paramref name="dim" /> is not zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length 1.</returns>
      <remarks>
        <para>For floating point elements: special floating point values (<see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, etc.; being 'not zero')
            evaluate to 'true'.</para>
        <para>Empty arrays are allowed. In difference to <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> or
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)" /> dimension <paramref name="dim" /> may be of length 0, which leads to a
            singleton dimension in the result and the non-existing elements evaluate to 'false'.</para>
        <para>The default value for <paramref name="dim" /> is -1. It causes the function to determine the working dimension (numpy: 'axis') automatically.
            This search is based on <see cref="M:ILNumerics.Size.WorkingDimension" /> and starts looking at the first dimension for <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            For <see cref="P:ILNumerics.Settings.ArrayStyle" /><see cref="F:ILNumerics.ArrayStyles.numpy" />, however, the search starts with the last dimension and works its way up to the first dimension.
            If the array does not contain any non-singleton dimension 0 is returned in both cases.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Size.WorkingDimension" />
      <see cref="P:ILNumerics.Settings.ArrayStyle" />
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Int64})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Int32})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Int16})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Byte})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.SByte})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Single})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Double})">
      <summary>
Tests if any elements of <paramref name="A" /> are non-zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if a test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.anyall(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Tests if any elements of <paramref name="A" /> are non-zero.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar logical. True if the test for non-zero succeeded for any element of <paramref name="A" />. False otherwise.</returns>
      <remarks>
        <para>The operation is efficiently performed and elements of the input array <paramref name="A" /> are not iterated if the number of Trues are known for the logical input.</para>
        <para>If elements must be iterated the operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>For floating point element types, 'not a number' (<see cref="F:System.Single.NaN" />) and other special floating point values (Inf) are considered non-zero.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Func{System.Double,System.Double,System.Double})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64},System.Func{System.UInt64,System.UInt64,System.UInt64})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64},System.Func{System.Int64,System.Int64,System.Int64})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32},System.Func{System.UInt32,System.UInt32,System.UInt32})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32},System.Func{System.Int32,System.Int32,System.Int32})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16},System.Func{System.UInt16,System.UInt16,System.UInt16})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16},System.Func{System.Int16,System.Int16,System.Int16})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte},System.Func{System.Byte,System.Byte,System.Byte})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte},System.Func{System.SByte,System.SByte,System.SByte})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: apply(A,B).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})" /> expect two
            arrays of broadcastable size with the same element types. They perform a mapping operation on corresponding elements
            of <paramref name="A" /> and <paramref name="B" /> by evaluating <paramref name="func" /> for each element of the resulting array.</para>
        <para>Overloads of <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Func{System.Single,System.Single,System.Single})" /> perform fastest where
            the element type of the input and the output arrays match. Such overloads exist for all numeric value-typed element types.</para>
        <para>The function is efficiently parallelized and <paramref name="func" /> is evaluated from multiple threads. Make sure that <paramref name="func" />
            is threadsafe!</para>
        <para>For more flexibility a generic overload exist which allows the element types of <paramref name="A" />, <paramref name="B" />
            as well as the array returned to be individual different. See: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.convert``2(ILNumerics.BaseArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.apply``1(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``0},System.Func{``0,``0,``0})">
      <summary>
            Binary, elementwise, broadcasting operation: <![CDATA[Apply<T>]]>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})">
      <summary>
            Binary, elementwise, broadcasting <![CDATA[apply<T1,T2,Tout>]]>(A,B). Maps a scalar operation from elements of <paramref name="A" /> and <paramref name="B" /> to a third array. Arbitrary types. Parallelized.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding elements of <paramref name="A" /> and <paramref name="B" />.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,System.Int64,``2})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,System.Int64,``2})">
      <summary>
            Binary, elementwise, broadcasting <![CDATA[apply<T1,T2,long,Tout>]]>(A,B). Maps a scalar operation from elements of
            <paramref name="A" /> and <paramref name="B" /> to a third array, provides element index. Arbitrary types. Parallelized.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="func">The elementary (scalar) function to be used to perform the operation on corresponding
            elements of <paramref name="A" /> and <paramref name="B" />, utilizing respective element values and the index
            used to locate the output array in iteration order.</param>
      <returns>New or reused array with result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>The iteration order depends on the order of input arrays: for column major
            input <c>i</c> will run in column major order and in row major order for row major inputs. If inputs have
            other, undefined or different storage orders the result is undefined. It is recommended to use this function on vector input(s)
            or with a well defined storage order for inputs <paramref name="A" /> and/or <paramref name="B" />.</para>
        <para>This function may automatically work inplace on either of both input parameters, if possible.</para>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>'Merge' elements a of an vector of 0's with a scalar -1, weighting with the location index <c>i</c> by applying the function: <c>c = a + i * b</c>.</para>
        <code><![CDATA[Array<int> C = apply(zeros<int>(10,1), vector(-1), (a, b, i) => (int)(a + i * b));
            C
            <Int32> [10,1] 0...-9 |
            [0]:            0
            [1]:           -1
            [2]:           -2
            [3]:           -3
            [4]:           -4
            [5]:           -5
            [6]:           -6
            [7]:           -7
            [8]:           -8
            [9]:           -9
            ]]></code>
        <para>Efficiently overwrite/initialize the content of an uninitialized array with upwards counting values, row major storage order.</para>
        <code><![CDATA[Array<double> D = apply(empty<double>(4, 3, 2, StorageOrders.RowMajor), zeros(1), (a, b, i) => (double)i);
            D
            <Double> [4,3,2] 0...23 -
            [0]: (:,:,0)
            [1]:            0           2           4
            [2]:            6           8          10
            [3]:           12          14          16
            [4]:           18          20          22
            [5]: (:,:,1)
            [6]:            1           3           5
            [7]:            7           9          11
            [8]:           13          15          17
            [9]:           19          21          23
            ]]></code>
        <para>The last example produces the same result as the expression: <c>counter(4,3,2, StorageOrders.RowMajor);</c>. The larger flexibility
            in the generator function <paramref name="func" /> comes with a slight computational overhead, though.</para>
      </example>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``1(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``0},System.Func{``0,``0,``0})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.apply``3(ILNumerics.BaseArray{``0},ILNumerics.BaseArray{``1},System.Func{``0,``1,``2})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros(ILNumerics.InArray{System.Int64})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.arange(System.Double,System.Double)">
      <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <returns>Vector with n equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.arange(System.Double,System.Double,System.Double)">
      <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <param name="step">Step value.</param>
      <returns>Vector with n equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange(System.Double,System.Double)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.arange``1(``0,``0)">
      <summary>
            Creates vector of evenly spaced values over a closed interval, elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <returns>Vector with n equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``1(``0,``0)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />,
            if <typeparamref name="T" /> is not a supported numeric value type, if <paramref name="start" /> or <paramref name="end" /> is
            not scalar, is null or is not of a supported numeric, convertible element type.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.arange``2(``0,``1,``0)">
      <summary>
            Creates vector of N evenly spaced values of given step size over a closed interval, numeric, real elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value.</param>
      <param name="step">Step size.</param>
      <param name="end">End value.</param>
      <returns>(Column) vector of length N.</returns>
      <remarks>
        <para>The function creates N values from <paramref name="start" /> to <paramref name="end" />, all equally spaced with stepsize <paramref name="step" />.<paramref name="step" />.</para>
        <para>The last element of the returned vector will be less than or equal to <paramref name="end" />, if <paramref name="start" /><![CDATA[<]]><paramref name="end" />. </para>
        <para>If <paramref name="start" /><![CDATA[>]]><paramref name="end" /> elements in the vector will linearly <i>decrease</i> from
            <paramref name="start" /> to <paramref name="end" />. In this case, <paramref name="step" /> must be negative.</para>
        <para>Values are computed in the precision of the datatype <typeparamref name="T" />. For integer <typeparamref name="T" /> this may imply rounding issues.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if either of <paramref name="start" />, <paramref name="end" />, or
            <paramref name="step" /> is null, non-numeric, or non-scalar, if <paramref name="step" /> is 0 or the sign
            of <paramref name="step" /> does not match the sign of 'end - start'.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,ILNumerics.Size,ILNumerics.StorageOrders)">
      <summary>
            Create new array, fill elements with constant value
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements.</param>
      <param name="size">Size of new array</param>
      <param name="order">[Optional] storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"></see>.</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates new array of dimension lengths, with all elements having the same value <paramref name="val" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The target element value.</param>
      <param name="size">Vector with dimension lengths, as created by Math.size().</param>
      <param name="order">[Optional] storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"></see>.</param>
      <returns>New array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[],ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array from the values provided in <paramref name="values" /> with the shape given by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Values to be copied to the new ILNumerics array.</param>
      <param name="size">The size of the new ILNumerics array. Number of elements must correspond to the number of values in <paramref name="values" />.</param>
      <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</param>
      <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
      <remarks>A copy is made from <paramref name="values" />. The array <paramref name="values" /> is not referenced
            by ILNumerics after the function returns.
            <para>Make sure that the number of elements configured by the dimension lengths in <paramref name="size" />
            match the number of values of <paramref name="values" />.</para><para>This function is a convenience alias for 'vector(<paramref name="values" />).Reshape(<paramref name="size" />,<paramref name="order" />)'.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[0:,0:])">
      <summary>
            Creates a vector from <paramref name="values" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Variable number of values for the new vector.</param>
      <returns>A vector of <typeparamref name="T" /> elements, 1D in numpy array style, a column vector otherwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[0:,0:,0:])">
      <summary>
            Creates a vector from <paramref name="values" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Variable number of values for the new vector.</param>
      <returns>A vector of <typeparamref name="T" /> elements, 1D in numpy array style, a column vector otherwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[0:,0:,0:,0:])">
      <summary>
            Creates a vector from <paramref name="values" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Variable number of values for the new vector.</param>
      <returns>A vector of <typeparamref name="T" /> elements, 1D in numpy array style, a column vector otherwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int32[])">
      <summary>
            Create new array, fill element with constant value
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="value">Constant value for all elements</param>
      <param name="size">Size of new array</param>
      <returns>New array according to size with all elements set to 'value'</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[])">
      <summary>
            Creates a vector from <paramref name="values" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Variable number of values for the new vector.</param>
      <returns>A vector of <typeparamref name="T" /> elements, 1D in numpy array style, a column vector otherwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(ILNumerics.Size,``0[])">
      <summary>
            Creates an array from <paramref name="values" /> and <paramref name="size" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="size">Source size descriptor providing the dimension lengths for the new array.</param>
      <param name="values">Values for the new array.</param>
      <returns>Array of <typeparamref name="T" /> elements and a size according to <paramref name="size" />.</returns>
      <exception cref="T:System.ArgumentException">if the size given by <paramref name="size" /> does not match the number of <paramref name="values" /> provided.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[],System.Int32[])">
      <summary>
            Creates an array from <paramref name="values" /> and <paramref name="size" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="size">Size descriptor providing the dimension lengths for the new array.</param>
      <param name="values">Values for the new array will be copied from this System.Array.</param>
      <returns>Array of <typeparamref name="T" /> elements and a size according to <paramref name="size" />.</returns>
      <exception cref="T:System.ArgumentException">if the size given by <paramref name="size" /> does not match the number of <paramref name="values" /> provided.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0[],ILNumerics.Size)">
      <summary>
            Creates an array from <paramref name="values" />. Column major storage.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="size">Source size descriptor providing the dimension lengths for the new array.</param>
      <param name="values">Values for the new array.</param>
      <returns>Array of <typeparamref name="T" /> elements and a size according to <paramref name="size" />.</returns>
      <exception cref="T:System.ArgumentException">if the size given by <paramref name="size" /> does not match the number of <paramref name="values" /> provided.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{``0},ILNumerics.StorageOrders)">
      <summary>
            Creates an ILNumerics array from <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">Enumerable with values for the new array.</param>
      <param name="size">[Optional] size for the new array. Default: (null) creates a vector according to the number of given values.</param>
      <param name="order">[Optional] Storage order for the new cell. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>ILNumerics array with shallow copy of the values taken from <paramref name="values" />.</returns>
      <remarks>
        <para>If <paramref name="size" /> is provided the number of elements as determined by the number and lengths of
            dimensions in <paramref name="size" /> must match the actual number of elements found in <paramref name="values" />.</para>
        <para>
          <paramref name="values" /> is iterated exactly once.</para>
        <para>If <typeparamref name="T" /> is a reference type and/or <see cref="T:System.IDisposable" /> a shallow copy
            of the reference value is made only. No interface methods are called on the elements of <paramref name="values" />.</para>
        <para>If both, <paramref name="size" /> and <paramref name="values" /> are null, an empty array is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.array``1(``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array, all elements initialized with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="val">The value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with <paramref name="val" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Angles of cosine elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Angles of cosine elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Asin(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.BaseArray{System.Single})">
      <summary>
Angles of cosine elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:System.Math.Asin(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asin(ILNumerics.BaseArray{System.Double})">
      <summary>
Angles of cosine elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:System.Math.Asin(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asinc(ILNumerics.BaseArray{System.Single})">
      <summary>
Angles of cosine elements, complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Asin(System.Single)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.asinc(ILNumerics.BaseArray{System.Double})">
      <summary>
Angles of cosine elements, complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose sine corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Asin(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Angles of tangent array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Angles of tangent array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:ILNumerics.complex.Atan(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.BaseArray{System.Single})">
      <summary>
Angles of tangent array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:System.Math.Atan(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan(ILNumerics.BaseArray{System.Double})">
      <summary>
Angles of tangent array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>The angle whose tangent corresponds to the array elements. See: <see cref="M:System.Math.Atan(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan2(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: Atan2.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.atan2(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Atan2.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ0(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 1.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ0(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 1.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ1(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJ1(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJn(ILNumerics.InArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselJn(ILNumerics.InArray{System.Single},System.Int32)">
      <summary>
            Evaluates the Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_first_kind">Wikipedia - Bessel functions of the first kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI0(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI0(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI1(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedI1(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedIn(ILNumerics.InArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedIn(ILNumerics.InArray{System.Single},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the first kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Modified_Bessel_functions">Wikipedia - Modified Bessel functions</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, double.PositiveInfinity will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, 0.0 will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK0(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK0(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK1(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedK1(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedKn(ILNumerics.InArray{System.Double},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselModifiedKn(ILNumerics.InArray{System.Single},System.Int32)">
      <summary>
            Evaluates the modified Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>== 0.0</c>, double.PositiveInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY0(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY0(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 0 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY1(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselY1(ILNumerics.InArray{System.Single})">
      <summary>
            Evaluates the Bessel function of the second kind, integer order 1 of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselYn(ILNumerics.InArray{System.Double},System.Int32)">
      <summary>
            Evaluates the Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.besselYn(ILNumerics.InArray{System.Single},System.Int32)">
      <summary>
            Evaluates the Bessel function of the second kind, integer order n-th of the argument.
            For more details about this function, see <a href="http://en.wikipedia.org/w/index.php?title=Bessel_function#Bessel_functions_of_the_second_kind">Wikipedia - Bessel functions of the second kind</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <param name="n">Integer order of the argument.</param>
      <returns>The value of the function.
            </returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="x" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If the order <paramref name="n" /> is negative, an ArgumentException will be thrown.</item>
          <item>If any element of <paramref name="x" /> is <c>xi &lt; 0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.beta(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
Evaluates the componentwise beta function at an array of points defined by <paramref name="w" /> and <paramref name="z" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function">Wikipedia - Beta function</a>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="z">Input array.</param>
      <param name="w">Input array so that <paramref name="z" /> &gt; <paramref name="w" /> for all component.</param>
      <returns> An array of same size as <paramref name="z" /> and with component values of the beta function.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="z" />i &lt; <paramref name="w" />i, the solution will be double.NaN.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If z and w size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.betaIncomplete(System.Double,System.Double,ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the incomplete Beta function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function">Wikipedia - Incomplete beta function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated. <paramref name="x" />  must be in [0,1].</param>
      <param name="a">A scalar, first parameter of the incomplete Beta function.</param>
      <param name="b">A scalar, second parameter of the incomplete Beta function.</param>
      <returns>The value of the incomplete Beta function at a given point.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi &gt; 1</c> and <c>xi &lt; 1</c>, double.NaN will be returned at that element.</item>
          <item>If any element of x is <c>xi == 0</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == 1</c>, 1.0 will be returned at that element.</item>
          <item>If a or b is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.binomialCoefficients(ILNumerics.InArray{System.Int32},ILNumerics.InArray{System.Int32})">
      <summary>
            Binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.binomialCoefficientsLog(ILNumerics.InArray{System.Int32},ILNumerics.InArray{System.Int32})">
      <summary>
            Natural logarithm of binomial coefficients of elements in <paramref name="n" /> and <paramref name="k" />.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">Wikipedia - Binomial coefficient</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="n">Input array <paramref name="n" />.</param>
      <param name="k">Input array <paramref name="k" />.</param>
      <returns>An array of same size as <paramref name="n" /> and <paramref name="k" /> with values of the binomial coefficients.</returns>
      <remarks>
        <list type="bullet">
          <item>If one of the input arrays is empty, an empty array will be returned.</item>
          <item>If for any component, one has <paramref name="n" />i &lt; <paramref name="k" />i, the solution will be double.NaN.</item>
          <item>If any elements in <paramref name="n" /> and <paramref name="k" /> has the same value, the solution will be +1.0.</item>
          <item>If any elements in <paramref name="n" /> or <paramref name="k" /> has a negative value, the solution will be double.NaN.</item>
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If n and k size are not equal, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitand(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitAnd.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.Int64})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.Int32})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.Int16})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.Byte})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitneg(ILNumerics.BaseArray{System.SByte})">
      <summary>
Bitwise negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Bitwise negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitOr.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.bitxor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitXor.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinates</param>
      <param name="Y">Y coordinates</param>
      <param name="Z">Z coordinates (height). Can be null if <paramref name="outZ" /> is not requested.</param>
      <param name="Radius">[Optional] Output: radius. Default: (null) do not compute.</param>
      <param name="outZ">[Optional] Output: Copy of Z. Default: (null) do not return.</param>
      <returns>Angles. Radius and Z values are returned as output parameters if requested on entry (i.e.: not null).</returns>
      <remarks>
        <paramref name="X" />, <paramref name="Y" />, and <paramref name="Z" /> must be the
            same size or broadcastable to each other. Polar coordinate arrays returned are of the same
            size as the broadcasted size of the input arrays.
            <para>If <paramref name="outZ" /> is requested it will have the same values as <paramref name="Z" /> and
            the same broadcasted size of the output.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Transforms scalar coordinates into polar (cylindrical) coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinates.</param>
      <param name="Y">Y coordinates.</param>
      <param name="Z">Z coordinates (height).</param>
      <param name="Radius">[Optional] Output: radius. Default: (null) do not compute.</param>
      <param name="outZ">[Optional] Output: Copy of Z. Default: (null) do not return.</param>
      <returns>Angles. Radius and Z values are returned as output parameters if requested on entry (i.e.: not null).</returns>
      <remarks>
        <paramref name="X" />, <paramref name="Y" />, and <paramref name="Z" /> must be the
            same size or broadcastable to each other. Polar coordinate arrays returned are of the same
            size as the broadcasted size of the input arrays.
            <para>If <paramref name="outZ" /> is requested it will have the same values as <paramref name="Z" /> and
            the same broadcasted size of the output.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cart2sphere(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Transforms cartesian coordinates into spherical coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinate.</param>
      <param name="Y">Y coordinate.</param>
      <param name="Z">Z coordinate.</param>
      <param name="Theta">[Optional] Output: polar angle. Default: (null) do not compute.</param>
      <param name="Phi">[Optional] Output: Azimuthal angle. Default: (null) do not compute.</param>
      <returns>Array with the radius values.<paramref name="Theta" /> and <paramref name="Phi" /> are returned on request
            (i.e.: if not null on entry). </returns>
      <remarks> The input parameters <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />
            must be of the same size or broadcasting compatible. All arrays returned are of the broadcasted size <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cart2sphere(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Transforms cartesian coordinates into spherical coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">X coordinate.</param>
      <param name="Y">Y coordinate.</param>
      <param name="Z">Z coordinate.</param>
      <param name="Theta">[Optional] Output: polar angle. Default: (null) do not compute.</param>
      <param name="Phi">[Optional] Output: Azimuthal angle. Default: (null) do not compute.</param>
      <returns>Array with the radius values.<paramref name="Theta" /> and <paramref name="Phi" /> are returned on request
            (i.e.: if not null on entry). </returns>
      <remarks> The input parameters <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />
            must be of the same size or broadcasting compatible. All arrays returned are of the broadcasted size <para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: CComplex.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: CComplex.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Computes the smallest integer greater than or equal to elements in <paramref name="A" />
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size as <paramref name="A" /> with elements rounded up to the next integer. See: <see cref="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Computes the smallest integer greater than or equal to elements in <paramref name="A" />
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size as <paramref name="A" /> with elements rounded up to the next integer. See: <see cref="M:ILNumerics.complex.Ceiling(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.BaseArray{System.Single})">
      <summary>
Computes the smallest integer greater than or equal to elements in <paramref name="A" />
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size as <paramref name="A" /> with elements rounded up to the next integer. See: <see cref="M:System.Math.Ceiling(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ceil(ILNumerics.BaseArray{System.Double})">
      <summary>
Computes the smallest integer greater than or equal to elements in <paramref name="A" />
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size as <paramref name="A" /> with elements rounded up to the next integer. See: <see cref="M:System.Math.Ceiling(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)">
      <summary>
            Creates new cell, initialize size and provide arrays for cell elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">[Optional] Size hint for the new cell array. Default: (null) Derive the size from <paramref name="arrays" />.</param>
      <param name="arrays">[Optional] Enumerable of arrays for the cell elements, column major order. Default: (null) creates cell with all 'null' elements.</param>
      <param name="order">[Optional] Storage order for the new cell. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Cell of specified size, initialized with given arrays.</returns>
      <remarks>
        <para>If number of arrays given is smaller than the number of elements given by
            <paramref name="size" /> then trailing elements in the cell returned are set to null.</para>
        <para>If <paramref name="size" /> is null a cell vector is produced with a length corresponding to the number of elements in <paramref name="arrays" />.
            Performance wise it is recommended to specify the <paramref name="size" /> explicitly, though.</para>
        <para>If <paramref name="arrays" /> contains more elements than expected by <paramref name="size" /> an error is generated.</para>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.size(System.Int64,System.Int64,System.Int64,System.Int64)" /> function or one of its overloads are
            convenient for the specification of dimensional size arguments.</para>
        <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="Main">online documentation</a> for cell.</para>
        <para>Note that when <paramref name="arrays" /> is an ILNumerics array (as in the example where <paramref name="arrays" />
            was created by the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> function) memory management
            is performed accordingly: arrays stored in the <paramref name="arrays" /> object are released and the associated
            memory is released to the pool after the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)" /> function returns.
            However, for <paramref name="arrays" /> of other (non-ILNumerics) types proper memory management is not guaranteed. For
            example, when providing the target cell element values in a <see cref="T:System.Array" /> of <see cref="T:ILNumerics.BaseArray" /> a copy
            of individual elements is made by the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)" /> function before storing
            the new element into the cell object. The source object remains an element of the system array and is not released! </para>
        <para>Therefore, in situations where performance is critical and inside loops use one of the ILNumerics array intialization
            functions for providing the <paramref name="arrays" /> argument. Otherwise, temporary objects in the <see cref="T:System.Collections.Generic.IEnumerable`1" />
            may remain live and are left for the GC to clean up (which is fine, except for high performance demands).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example><![CDATA[
            <code>
            Array<double> A = rand(10,20,30);
            Cell C = cell(size(3,2),vector<BaseArray>(A, A+1, zeros<float>(2,3), "4th element"));
            //Alternatives:
            //Cell C = cell(size(3,2),new [] { A, A+1, zeros(2,3) });
            //Cell C = cell(size(3,2),row(A, A+1, zeros(2,3)));
            C
            >Cell [3,2]
            >    [0]:
            >    [1]:     {<Double> [10,20,30]}         {<String> [1,1]}
            >    [2]:     {<Double> [10,20,30]}                   {null}
            >    [3]:          {<Single> [2,3]}                   {null}
            </code>]]></example>
      <exception cref="T:System.ArgumentException"> if <paramref name="size" /> is not null and the number of elements found in <paramref name="arrays" /> exceeds
            the expected number of elements as specified by <paramref name="size" />.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cellv(ILNumerics.BaseArray[])" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape``1(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.cell(ILNumerics.BaseArray[],System.Int32[])">
      <summary>
            Create cell, initialize with arrays and size.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="values">Predefined system array with ILNumerics arrays as elements to be stored into the new cell.</param>
      <param name="size">Size of the new cell array.</param>
      <returns>Cell with size of <paramref name="size" /> and elements from <paramref name="values" /></returns>
      <remarks>
        <para>The arrays given in <paramref name="values" /> are stored into the new cell as
            individual cell elements. As for all cell elements, a (lazy) clone is made prior to
            storing the arrays into the cell. Therefore, the arrays are properly protected from
            changes from outside the cell.</para>
        <para>This function is deprecated and will be removed in a future version. Consider
            using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)" /> instead which does not
            rely on <c>params</c> arguments.</para>
        <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="Main">online documentation</a> for cell.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cell(ILNumerics.InArray{System.Int64},System.Collections.Generic.IEnumerable{ILNumerics.BaseArray},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0)" />
    </member>
    <member name="M:ILNumerics.ILMath.cellv(ILNumerics.BaseArray[])">
      <summary>
            Create a cell vector from provided <paramref name="arrays" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="arrays">ILNumerics arrays to be stored into the cell.</param>
      <returns>Cell array with number and values of elements as given by <paramref name="arrays" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check``1(ILNumerics.InArray{``0},System.Func{ILNumerics.InArray{``0},ILNumerics.RetArray{``0}},System.Boolean,System.String,ILNumerics.InArray{``0})">
      <summary>
            Checks if <paramref name="A" /> is a valid parameter.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input array.</param>
      <param name="ErrorMessage">[Optional] Exception message.</param>
      <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for <paramref name="A" /> other than null</param>
      <param name="allowNullInput">[optional] Only if <paramref name="A" /> is null -&gt; for true: returns null, false: throws exception. If <paramref name="Default" /> was defined, this parameter is ignored.</param>
      <param name="Default">[optional] If <paramref name="A" /> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput" /> is evaluated.</param>
      <returns>Result of calling <paramref name="evaluation" />(<paramref name="A" />) or <paramref name="A" />.</returns>
      <exception cref="T:System.ArgumentException">If A was null on entry and <paramref name="allowNullInput" /> is false</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check(ILNumerics.InLogical,System.Func{ILNumerics.InLogical,ILNumerics.RetLogical},System.Boolean,System.String)">
      <summary>
            Checks if <paramref name="A" /> is a valid parameter.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="ErrorMessage">[Optional] Exception message. Default: empty string.</param>
      <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for <paramref name="A" /> other than null.</param>
      <param name="allowNullInput">[Optional] Only if <paramref name="A" /> is null -&gt; for true: returns null, false: throws exception.</param>
      <returns>Result of calling <paramref name="evaluation" />(<paramref name="A" />) or <paramref name="A" />.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="A" /> was null on entry and <paramref name="allowNullInput" /> is false.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.check(ILNumerics.InCell,System.Func{ILNumerics.InCell,ILNumerics.RetCell},System.Boolean,System.String)">
      <summary>
            Check if <paramref name="A" /> is a valid parameter.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="ErrorMessage">[Optional] Exception message</param>
      <param name="evaluation">[Optional] Evaluation function, checks <paramref name="A" /> and transforms it into result, gets only called for <paramref name="A" /> other than null.</param>
      <param name="allowNullInput">[Optional] Only if <paramref name="A" /> is null -&gt; true: returns null, false: throws exception.</param>
      <returns>Result of calling <paramref name="evaluation" />(<paramref name="A" />) or <paramref name="A" />.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="A" /> was null on entry and <paramref name="allowNullInput" /> is false.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.checknull``1(ILNumerics.InArray{``0},System.Func{ILNumerics.RetArray{``0}})">
      <summary>
            Checks if <paramref name="A" /> is valid, assign default if null.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="A">Input array.</param>
      <param name="onNull">Provides default value when <paramref name="A" /> is null. This is only evaluated when <paramref name="A" /> is null.</param>
      <returns>
        <paramref name="A" /> or the result returned from <paramref name="onNull" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.InArray{System.Double},System.Boolean)">
      <summary>
Cholesky factorization of a symmetric, positive definite matrix.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input matrix. <paramref name="A" /> must be a symmetric/hermitian matrix. </param>
      <param name="throwException">Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> is found to be not positive definite.</param>
      <returns>Cholesky factorization of <paramref name="A" />.</returns>
      <remarks>
        <para>No check is performed on <paramref name="A" />'s symmetry for performance reasons.</para>
        <para>If <paramref name="throwException" /> is true and
            <paramref name="A" /> is found to be not positive definite an <see cref="T:System.ArgumentException" />
            is thrown and the operation is canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the
            operation (unless you are sure, <paramref name="A" /> was positive definite).
            If <paramref name="A" /> was found not to be positive definite the matrix returned
            will be of dimension [k x k] and the result of the cholesky
            factorization of A[0:k-1;0:k-1]. Here k is the first leading
            minor of <paramref name="A" /> at which <paramref name="A" /> was found to be not positive definite.</para>
        <para>The factorization is carried out by use of the LAPACK functions
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.InArray{System.Single},System.Boolean)">
      <summary>
Cholesky factorization of a symmetric, positive definite matrix.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input matrix. <paramref name="A" /> must be a symmetric/hermitian matrix. </param>
      <param name="throwException">Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> is found to be not positive definite.</param>
      <returns>Cholesky factorization of <paramref name="A" />.</returns>
      <remarks>
        <para>No check is performed on <paramref name="A" />'s symmetry for performance reasons.</para>
        <para>If <paramref name="throwException" /> is true and
            <paramref name="A" /> is found to be not positive definite an <see cref="T:System.ArgumentException" />
            is thrown and the operation is canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the
            operation (unless you are sure, <paramref name="A" /> was positive definite).
            If <paramref name="A" /> was found not to be positive definite the matrix returned
            will be of dimension [k x k] and the result of the cholesky
            factorization of A[0:k-1;0:k-1]. Here k is the first leading
            minor of <paramref name="A" /> at which <paramref name="A" /> was found to be not positive definite.</para>
        <para>The factorization is carried out by use of the LAPACK functions
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.InArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
Cholesky factorization of a symmetric, positive definite matrix.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input matrix. <paramref name="A" /> must be a symmetric/hermitian matrix. </param>
      <param name="throwException">Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> is found to be not positive definite.</param>
      <returns>Cholesky factorization of <paramref name="A" />.</returns>
      <remarks>
        <para>No check is performed on <paramref name="A" />'s symmetry for performance reasons.</para>
        <para>If <paramref name="throwException" /> is true and
            <paramref name="A" /> is found to be not positive definite an <see cref="T:System.ArgumentException" />
            is thrown and the operation is canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the
            operation (unless you are sure, <paramref name="A" /> was positive definite).
            If <paramref name="A" /> was found not to be positive definite the matrix returned
            will be of dimension [k x k] and the result of the cholesky
            factorization of A[0:k-1;0:k-1]. Here k is the first leading
            minor of <paramref name="A" /> at which <paramref name="A" /> was found to be not positive definite.</para>
        <para>The factorization is carried out by use of the LAPACK functions
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.chol(ILNumerics.InArray{ILNumerics.complex},System.Boolean)">
      <summary>
Cholesky factorization of a symmetric, positive definite matrix.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input matrix. <paramref name="A" /> must be a symmetric/hermitian matrix. </param>
      <param name="throwException">Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> is found to be not positive definite.</param>
      <returns>Cholesky factorization of <paramref name="A" />.</returns>
      <remarks>
        <para>No check is performed on <paramref name="A" />'s symmetry for performance reasons.</para>
        <para>If <paramref name="throwException" /> is true and
            <paramref name="A" /> is found to be not positive definite an <see cref="T:System.ArgumentException" />
            is thrown and the operation is canceled.</para>
        <para>If <paramref name="throwException" /> is false, check the
            return value's dimension to determine the success of the
            operation (unless you are sure, <paramref name="A" /> was positive definite).
            If <paramref name="A" /> was found not to be positive definite the matrix returned
            will be of dimension [k x k] and the result of the cholesky
            factorization of A[0:k-1;0:k-1]. Here k is the first leading
            minor of <paramref name="A" /> at which <paramref name="A" /> was found to be not positive definite.</para>
        <para>The factorization is carried out by use of the LAPACK functions
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.column``1(``0[])">
      <summary>
            Creates a column vector. This function is deprecated. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])" /> instead.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the column vector.</param>
      <returns>New column vector.</returns>
      <remarks>
        <para>The same effect is achieved by: <![CDATA[<c>vector<T>(elements).Reshape(Equals(elements, null) ? 0 : elements.Length, 1)</c>]]>.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)">
      <summary>
            Create new array with the elements of <paramref name="A" /> and <paramref name="B" /> concatenated along dimension <paramref name="dim" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The other array.</param>
      <param name="dim">Dimension index to align both arrays elements along.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>The size of both arrays must match. This means that all but the dimension #<paramref name="dim" />
            must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <paramref name="dim" /> is not within the range of dimensions of the arrays or if the sizes of <paramref name="A" /> and <paramref name="B" /> do not match.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="B" /> are null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Creates the complex conjugate of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the complex conjugate of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conj(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Creates the complex conjugate of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the complex conjugate of A's array elements. See: <see cref="M:ILNumerics.complex.Cos(ILNumerics.complex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conjInplace(ILNumerics.Core.Arrays.Mutable{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})">
      <summary>
Conjugates complex elements inplace.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Mutable input array.</param>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" /> inplace.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>Elements of the input array <paramref name="A" /> are directly altered. New memory is only used if the elements
            of <paramref name="A" /> are currently shared with other arrays. Only in this case a copy is created automatically.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.conjInplace(ILNumerics.Core.Arrays.Mutable{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}})">
      <summary>
Conjugates fcomplex elements inplace.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Mutable input array.</param>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" /> inplace.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>Elements of the input array <paramref name="A" /> are directly altered. New memory is only used if the elements
            of <paramref name="A" /> are currently shared with other arrays. Only in this case a copy is created automatically.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.convert``1(ILNumerics.BaseArray)">
      <summary>
            Converts numeric array of unknown type to a specific array type.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="outT">Target element type.</typeparam>
      <param name="A">Source array.</param>
      <returns>Array of the same shape and size and element type of <typeparamref name="outT" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.convert``2(ILNumerics.BaseArray{``0})">
      <summary>
            Convert typed source array <paramref name="A" /> into array of element type <typeparamref name="outT" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="inT">Source element type.</typeparam>
      <typeparam name="outT">Target element type.</typeparam>
      <param name="A">Source array.</param>
      <returns>Array of the same shape  and size than <paramref name="A" />, having the element values converted to type <typeparamref name="outT" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.copyUpperTriangle``1(ILNumerics.InArray{``0},System.Int64,System.Int64)">
      <summary>
            Copy upper triangle from PHYSICAL array A
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Arbitrary inner type </typeparam>
      <param name="A">PHYSICAL Array</param>
      <param name="m">Number of rows</param>
      <param name="n">Number of columns</param>
      <returns>Newly created physical array with the upper triangle of A</returns>
      <remarks>No checks are made for m,n fit inside A!<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the cosine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the cosine of A's array elements. See: <see cref="M:ILNumerics.complex.Cos(ILNumerics.complex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.BaseArray{System.Single})">
      <summary>
Cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the cosine of A's array elements. See: <see cref="M:System.Math.Cos(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cos(ILNumerics.BaseArray{System.Double})">
      <summary>
Cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the cosine of A's array elements. See: <see cref="M:System.Math.Cos(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic cosine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Hyperbolic cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic cosine of A's array elements. See: <see cref="M:ILNumerics.complex.Cosh(ILNumerics.complex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.BaseArray{System.Single})">
      <summary>
Hyperbolic cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic cosine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cosh(ILNumerics.BaseArray{System.Double})">
      <summary>
Hyperbolic cosines of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic cosine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values in double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter(System.Int32[])">
      <summary>
            Create an array with regularly (stepsize 1) spaced elements in multiple dimensions of provided lenghts.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="sizes">Dimension lengths.</param>
      <returns>New ILNumerics array, initialized with elements starting at 1, increasing by 1 for each next element along the columns.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="size">Dimension lengths as vector.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the <paramref name="size" /> parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.counter``1(``0,``0,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array with regularly spaced element values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="start">The start value for the new elements.</param>
      <param name="step">The step size value for the new elements.</param>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with linearly spaced elements according to <paramref name="start" /> and counting up/downwards by <paramref name="step" /> along the storage order.</returns>
      <remarks>
        <para>The <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> function and the corresponding
            overloads for providing individual dimension length parameters <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,ILNumerics.StorageOrders)" />,...
            create n-dimensional numeric arrays with automatically generated values based on a given <paramref name="start" /> value and a <paramref name="step" /> value.
            The size of the new array is determined by the 'size' parameter(s). The firsts element value is assigned
            the <paramref name="start" /> value. Subsequent values are computed by adding the value of <paramref name="step" /> to each elements predecessor.</para>
        <para>The term 'predecessor' here means: the predecessor E0 of element E1 is the element having an index I(E0) of I(E1) - 1,
            where the index I() corresponds to the storage location of the element in memory, relative to the first element.</para>
        <para>The storage order is determined by <paramref name="order" />. By default, elements are lined up in memory
            in column major storage order. <paramref name="order" /> must be one out of <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />. Note, how the storage order affects the order of values in the new array.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <para>Creating a new array of size [4,3], filled with upwards counting values, starting at 1.</para>
        <code><![CDATA[Array<double> A = counter<double>(1, 1, 4, 3);
            //<Double> [4,3] 1...12 |
            //    [0]:           1          5          9
            //    [1]:           2          6         10
            //    [2]:           3          7         11
            //    [3]:           4          8         12]]></code>
        <para>Creating a new array of size [4,3,2] of ushort values: </para>
        <code><![CDATA[counter<sbyte>(10, -10, 4,3,2)
            //<SByte> [4,3] 1...12 |
            //    [0]: (:,:,0)
            //    [1]:    10  -30  -70
            //    [2]:     0  -40  -80
            //    [3]:   -10  -50  -90
            //    [4]:   -20  -60 -100
            //    [5]: (:,:,1)
            //    [6]:  -110  106   66
            //    [7]:  -120   96   56
            //    [8]:   126   86   46
            //    [9]:   116   76   36]]></code>
        <para>Note, how the computed values of data type 'sbyte' wrap around at the limits of 'sbyte'
            without notice!</para>
        <para>Creating a new array of size [4,3] with upwards counting values in row major order: </para>
        <code><![CDATA[counter<float>(1, 1, 4,3, StorageOrders.RowMajor)
            //<Single> [4,3] 1...12 -
            //    [0]:           1          2          3
            //    [1]:           4          5          6
            //    [2]:           7          8          9
            //    [3]:          10         11         12
            //]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.cross(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Boolean,System.Nullable{System.UInt32})">
      <summary>
            Computes the cross product along a dimension of two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">First array.</param>
      <param name="B">Second array.</param>
      <param name="normalize">[Optional] If true: normalize resulting vectors to length 1.0. Default: false.</param>
      <param name="dimension">[Optional] The working dimension. Default: (null) the first dimension of length 3.</param>
      <returns>Array with cross products of vectors from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>
          <paramref name="A" /> and <paramref name="B" /> are expected to store the vectors inside the same respective dimensions.
            This dimension must be of length 3 or longer. If <paramref name="dimension" /> is not specified the working dimension if found by
            searching for the first dimension of length 3, starting with dimension #0. If no dimension of length 3 is found, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cross(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Boolean,System.Nullable{System.UInt32})" />
            uses the first dimension which has more than 3 elements. If no such dimension is found either an exception is thrown.</para>
        <para>The <paramref name="dimension" /> argument allows to explicitly determine the index of the working dimension. The length of
            this dimension must be equal to or larger than 3. Both, <paramref name="A" /> and <paramref name="B" /> must be of the same size.</para>
        <para>Elements in the working dimension with indices &gt; #2 are ignored. Corresponding elements in the output array become 0.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If the size of <paramref name="A" /> and <paramref name="B" /> is not the same or
            if either of <paramref name="A" /> or <paramref name="B" /> is null, if the working dimension could not be determined or if the determined
            workign dimension is not at least of length 3.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.cross(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Boolean,System.Nullable{System.UInt32})">
      <summary>
            Computes the cross product along a dimension of two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">First array.</param>
      <param name="B">Second array.</param>
      <param name="normalize">[Optional] If true: normalize resulting vectors to length 1.0. Default: false.</param>
      <param name="dimension">[Optional] The working dimension. Default: (null) the first dimension of length 3.</param>
      <returns>Array with cross products of vectors from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>
          <paramref name="A" /> and <paramref name="B" /> are expected to store the vectors inside the same respective dimensions.
            This dimension must be of length 3 or longer. If <paramref name="dimension" /> is not specified the working dimension if found by
            searching for the first dimension of length 3, starting with dimension #0. If no dimension of length 3 is found, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.cross(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Boolean,System.Nullable{System.UInt32})" />
            uses the first dimension which has more than 3 elements. If no such dimension is found either an exception is thrown.</para>
        <para>The <paramref name="dimension" /> argument allows to explicitly determine the index of the working dimension. The length of
            this dimension must be equal to or larger than 3. Both, <paramref name="A" /> and <paramref name="B" /> must be of the same size.</para>
        <para>Elements in the working dimension with indices &gt; #2 are ignored. Corresponding elements in the output array become 0.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If the size of <paramref name="A" /> and <paramref name="B" /> is not the same or
            if either of <paramref name="A" /> or <paramref name="B" /> is null, if the working dimension could not be determined or if the determined
            workign dimension is not at least of length 3.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.csvread``1(System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo)">
      <summary>
            Reads comma separated values from lines in a string, optionally using custom separators, element and number formats.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="csvData">String with CSV data in lines.</param>
      <param name="startRow">[Optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[Optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[Optional] Index of the last row to take into account. Default: last row in <paramref name="csvData" />.</param>
      <param name="endCol">[Optional] Index of the last column to take into account. Default: last column in <paramref name="csvData" />.</param>
      <param name="elementConverter">[Optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[Optional] String separating individual elements. Default: , (comma)</param>
      <param name="culture">[Optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <returns>Matrix with elements read from <paramref name="csvData" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="csvData" /> is parsed using <paramref name="elementSeparator" /> as element
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the
            <see href="System.Globalization.NumberFormatInfo">number format info</see> provided in <paramref name="culture" />. The number
            format provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvread``1(System.IO.Stream,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Func{System.String,``0},System.String,System.Globalization.CultureInfo,System.Text.Encoding,System.Boolean)">
      <summary>
            Reads comma separated values from stream, optionally using custom separators, element and number formats.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type to return.</typeparam>
      <param name="stream">Stream with CSV data in lines.</param>
      <param name="startRow">[Optional] Start reading the values from that row. Default: 0.</param>
      <param name="startCol">[Optional] Start reading values from that column. Default: 0.</param>
      <param name="endRow">[Optional] Index of the last row to take into account. Default: last row in <paramref name="stream" />.</param>
      <param name="endCol">[Optional] Index of the last column to take into account. Default: last column in <paramref name="stream" />.</param>
      <param name="elementConverter">[Optional] Custom function to convert each element from its string representation. Default: parse as <see cref="T:System.Double" />.</param>
      <param name="elementSeparator">[Optional] String separating individual elements. Default: , (comma)</param>
      <param name="culture">[Optional] Number format used while parsing individual elements. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[Optional] Encoding used to read bytes from stream. Default: ASCII encoding.</param>
      <param name="leaveStreamOpen">[Optional] If set to true <paramref name="stream" /> will not be closed by this method. Default: false.</param>
      <returns>Matrix with elements read from <paramref name="stream" />.</returns>
      <remarks>
        <para>The data lines in <paramref name="stream" /> are parsed using <paramref name="elementSeparator" /> as element
            separator. Arbitrary element types <typeparamref name="T" /> can be parsed by providing a customized function
            <paramref name="elementConverter" /> for parsing individual elements. The current threads culture is temporarily changed to use the
            <see href="System.Globalization.CultureInfo">number format info</see> provided in <paramref name="culture" />. The number
            format of the given culture provides the parser with info about decimal separators among others used to determine number formats for parsing.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.InArray{``0},System.IO.Stream,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding,System.Boolean)">
      <summary>
            Write ILNumerics array as separated strings to stream
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="stream">Stream to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to separate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the stream.</param>
      <param name="leaveStreamOpen">[Optional] If set to true <paramref name="stream" /> will not be closed by this method. Default: false.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be separated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.InArray{``0},System.String,System.Func{``0,System.String},System.String,System.Globalization.CultureInfo,System.Text.Encoding)">
      <summary>
            Write ILNumerics array as separated strings to file
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of input array A</typeparam>
      <param name="A">ILNumerics array to write as CSV. This is expected to be a matrix.</param>
      <param name="filename">Name of the file to write values to.</param>
      <param name="elementConverter">[optional] Custom function used to convert elements of A to string. Default: [T].ToString()</param>
      <param name="elementSeparator">[optional] Character chain used to separate individual elements. Default: ',' (comma).</param>
      <param name="culture">[optional] Number format info used to acquire formatting information for converting numbers to string. Default: invariant culture (not current thread culture!)</param>
      <param name="encoding">[optional] Encoding used to write the string representation of individual elements to the bytes of the file.</param>
      <remarks>
        <para>A is expected to be a matrix. If A has more than 2 dimensions trailing dimensions will be joined to the second dimension. This corresponds to: A[":;:"].</para>
        <para>The optional parameters <paramref name="elementConverter" />, <paramref name="elementSeparator" /> and <paramref name="culture" />
            are used to control the format of the resulting CSV result.<paramref name="elementConverter" /> is used to convert a single element of <paramref name="A" /> into its string representation, using the current cultures number format or the <see cref="T:System.Globalization.CultureInfo" /> provided by <paramref name="culture" />.</para>
        <para>Individual elements will be separated in the CSV result by ',' (comma) or by the character chain provided by <paramref name="elementSeparator" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Single},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Int64},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.UInt64},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Int32},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.UInt32},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Int16},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.UInt16},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.SByte},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Byte},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.BaseArray{System.Double},System.Int32)">
      <summary>
Computes the product of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Double},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Single},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Int64},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.UInt64},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Int32},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.UInt32},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Int16},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.UInt16},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.SByte},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.BaseArray{System.Byte},System.Int32)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default: (-1) work along the first non-singleton dimension or along dimension #0.</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.InArray{System.Double})">
      <summary>
            Determinant of square matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square).</param>
      <returns>Determinant of <paramref name="A" />.</returns>
      <remarks>
        <para>The determinant is computed by decomposing <paramref name="A" /> into upper and lower triangular part using LU decomposition. </para>
        <para>The determinant of a scalar matrix is the scalar itself. If <paramref name="A" /> is empty an empty array will be returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
            <code><![CDATA[Array<double> A = ILMath.counter<double>(1.0, 1.0, 4, 4);
            A[1, 0] = 0.0;  // ensure that A
            A[2, 3] = 0.0;  // has full rank
            A
            <Double> [4,4] 1...16 order:|
            1          5          9         13
            0          6         10         14
            3          7         11          0
            4          8         12         16
            det(A)
            //D
            <Double> [1,1] -360 order:|
            ]]></code></example>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.InArray{System.Single})">
      <summary>
            Determinant of square matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square).</param>
      <returns>Determinant of <paramref name="A" />.</returns>
      <remarks>
        <para>The determinant is computed by decomposing <paramref name="A" /> into upper and lower triangular part using LU decomposition. </para>
        <para>The determinant of a scalar matrix is the scalar itself. If <paramref name="A" /> is empty an empty array will be returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (float) matrix and it's determinant
            <code><![CDATA[Array<float> A = ILMath.counter<float>(1.0, 1.0, 4, 4);
            A[1, 0] = 0.0;  // ensure that A
            A[2, 3] = 0.0;  // has full rank
            A
            <Double> [4,4] 1...16 order:|
            1          5          9         13
            0          6         10         14
            3          7         11          0
            4          8         12         16
            det(A)
            //D
            <Double> [1,1] -360 order:|
            ]]></code></example>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determinant of square matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square).</param>
      <returns>Determinant of <paramref name="A" />.</returns>
      <remarks>
        <para>The determinant is computed by decomposing <paramref name="A" /> into upper and lower triangular part using LU decomposition. </para>
        <para>The determinant of a scalar matrix is the scalar itself. If <paramref name="A" /> is empty an empty array will be returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (fcomplex) matrix and it's determinant
            <code><![CDATA[Array<fcomplex> A = ILMath.counter<fcomplex>(1.0, 1.0, 4, 4);
            A[1, 0] = 0.0;  // ensure that A
            A[2, 3] = 0.0;  // has full rank
            A
            <Double> [4,4] 1...16 order:|
            1          5          9         13
            0          6         10         14
            3          7         11          0
            4          8         12         16
            det(A)
            //D
            <Double> [1,1] -360 order:|
            ]]></code></example>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.det(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determinant of square matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix (square).</param>
      <returns>Determinant of <paramref name="A" />.</returns>
      <remarks>
        <para>The determinant is computed by decomposing <paramref name="A" /> into upper and lower triangular part using LU decomposition. </para>
        <para>The determinant of a scalar matrix is the scalar itself. If <paramref name="A" /> is empty an empty array will be returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>Creating a nonsingular 4x4 (complex) matrix and it's determinant
            <code><![CDATA[Array<complex> A = ILMath.counter<complex>(1.0, 1.0, 4, 4);
            A[1, 0] = 0.0;  // ensure that A
            A[2, 3] = 0.0;  // has full rank
            A
            <Double> [4,4] 1...16 order:|
            1          5          9         13
            0          6         10         14
            3          7         11          0
            4          8         12         16
            det(A)
            //D
            <Double> [1,1] -360 order:|
            ]]></code></example>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.diag``1(ILNumerics.BaseArray{``0},System.Int32)">
      <summary>
            Diagonal matrix or diagonal from matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix or vector.</param>
      <param name="d">[Optional] Index of diagonal to extract/ to create. Default: 0.</param>
      <returns>Depending on the shape of <paramref name="A" /> a matrix or a vector with the elements on the
            specified diagonal of <paramref name="A" />.</returns>
      <remarks>The type of the Array returned will be the same as the type of <paramref name="A" />.
            <para>If <paramref name="A" /> is a matrix, diag(<paramref name="A" />) returns the
            elements on the <paramref name="d" />'s diagonal as column vector. </para><para>If <paramref name="A" /> is vector, a square matrix of size
            [<paramref name="A" />.Length - abs(<paramref name="d" />), <paramref name="A" />.Length - abs(<paramref name="d" />)] will be created, having
            the elements of the <paramref name="d" />'s diagonal of <paramref name="A" />.</para><para>0 for <paramref name="d" /> means: the main diagonal, <paramref name="d" /> &gt; 0 is above the main diagonal, <paramref name="d" /> smaller 0 means
            below the main diagonal. <paramref name="d" /> must lay in the range of existing rows / columns of <paramref name="A" />.</para><para>In general the equality diag(diag(A))==A holds true on a vector or a matrix A.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException">If abs(<paramref name="d" />) addresses a non-existing diagonal.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Double},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{ILNumerics.fcomplex},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{ILNumerics.complex},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Single},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Int64},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.UInt64},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Int32},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.UInt32},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Int16},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.UInt16},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.SByte},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diff(ILNumerics.BaseArray{System.Byte},System.UInt32,System.Int32)">
      <summary>
            Computes the differences between successive elements of <paramref name="A" /> along the specified dimension <paramref name="dim" /> or the n-th derivative.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="N">[Optional] Order of difference. Default: 1.</param>
      <param name="dim">[Optional] The dimension index of the working dimension. Default (-1): first non-singleton dimension of <paramref name="A" /> or 0, if no such dimension exists.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced by 1 element.</returns>
      <remarks>
        <para>If the length of the <paramref name="dim" />s dimension in <paramref name="A" /> is lower than 2, an empty
            array is returned, having the size of <paramref name="A" /> but the <paramref name="dim" />s dimension reduced to max(A.S[dim]-1,0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.diGamma(ILNumerics.InArray{System.Double})">
      <summary>
            Computes the Digamma function which is mathematically defined as the derivative of the logarithm of the gamma function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Digamma_function">Wikipedia - Digamma function</a>
            and <a href="http://mathworld.wolfram.com/DigammaFunction.html">Wolfram MathWorld - Digamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="xi">The point where the function is evaluated.</param>
      <returns>The value of the DiGamma function at <paramref name="xi" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input <paramref name="xi" /> is null, ArgumentNullException will be thrown.</item>
          <item>If the input <paramref name="xi" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.NaN</c> or <c>xi == double.NegativeInfinity</c>, there will be a double.NaN returned at that element.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, there will be a double.PositiveInfinity returned at that element.</item>
          <item>If any element of x is <c>xi &lt; 0</c> and is a round number, there will be a double.NegativeInfinity returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{System.Int64},ILNumerics.InArray{System.Int64})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{System.Int32},ILNumerics.InArray{System.Int32})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Pairwise L1 distance. Aka: Manhattan distance.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input points (matrix).</param>
      <param name="B">Input point (vector).</param>
      <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B" /> and the data points stored in the matrix <paramref name="A" />.</returns>
      <remarks>
        <para>If <paramref name="B" /> is a colum vector, the distances between <paramref name="B" /> and the columns of <paramref name="A" /> are calculated. The number of rows of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A" />: <code>A.S[1]</code>.</para>
        <para>If <paramref name="B" /> is a row vector, the distances between <paramref name="B" /> and the rows of <paramref name="A" /> are calculated. The number of columns of <paramref name="A" />
            must match the length of vector <paramref name="B" /> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A" />: <code>A.S[0]</code>.</para>
        <para>This function is commutative, the single data point may be provided in <paramref name="A" /> and the data point matrix may be provided in <paramref name="B" /> as well.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL2sq(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Computes the [m x n] squared pairwise L2 distances between data points provided in <paramref name="A" /> [d x m] and <paramref name="B" /> [d x n].
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input data matrix <paramref name="A" /> [d x m], m points are provided as columns of length d.</param>
      <param name="B">Input data matrix <paramref name="B" /> [d x n], n points are provided as columns of length d.</param>
      <returns>Distance matrix D of size [m x n]. D<sub>i,j</sub> is the <i>squared</i> euclidian distance between data point <i>i</i> in A and data point <i>j</i> in B.</returns>
      <remarks>
        <para>This function computes the square of the pairwise euclidian (L2) distances between data values in <paramref name="A" /> and <paramref name="B" />.</para>
        <para>In order to get the non-squared distances one may use the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{System.Double})" /> function on the array returned.</para>
        <para>For those coming from languages like Matlab / Octave: the equivalent function there would be: <c>bsxfun(@plus, dot(X, X, 1)',dot(Y,Y,1))-2*(X' * Y)</c></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.distL2sq(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Computes the [m x n] squared pairwise L2 distances between data points provided in <paramref name="A" /> [d x m] and <paramref name="B" /> [d x n].
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input data matrix <paramref name="A" /> [d x m], m points are provided as columns of length d.</param>
      <param name="B">Input data matrix <paramref name="B" /> [d x n], n points are provided as columns of length d.</param>
      <returns>Distance matrix D of size [m x n]. D<sub>i,j</sub> is the <i>squared</i> euclidian distance between data point <i>i</i> in A and data point <i>j</i> in B.</returns>
      <remarks>
        <para>This function computes the square of the pairwise euclidian (L2) distances between data values in <paramref name="A" /> and <paramref name="B" />.</para>
        <para>In order to get the non-squared distances one may use the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sqrt(ILNumerics.BaseArray{System.Double})" /> function on the array returned.</para>
        <para>For those coming from languages like Matlab / Octave: the equivalent function there would be: <c>bsxfun(@plus, dot(X, X, 1)',dot(Y,Y,1))-2*(X' * Y)</c></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.divide_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Divide.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Double})">
      <summary>
            Computes eigenvalues of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <returns>Vector of eigenvalues of <paramref name="A" />. Size [n x 1].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned is complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Double})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Computes eigenvalues and eigenvectors of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. Default: (null) do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <returns>Diagonal matrix with eigenvalues of <paramref name="A" />. Size [n x n].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Double})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors of square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. If null: do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <param name="propsA">Matrix properties, on input - if specified,
            will be used to choose an advantageous path to the solution. On exit will be
            filled according to the properties of <paramref name="A" /> (symmetric | hermitian).</param>
      <param name="balance">True: permute <paramref name="A" /> in order to increase the
            numerical stability, false: do not permute <paramref name="A" />.</param>
      <returns>Eigenvalues as vector (if <paramref name="V" /> is null) or as diagonoal
            matrix (if <paramref name="V" /> was not null).</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Double})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>Depending on the parameter <paramref name="balance" /><paramref name="A" />
            will be balanced first. This includes permutations and scaling of A in order to
            improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Single})">
      <summary>
            Computes eigenvalues of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <returns>Vector of eigenvalues of <paramref name="A" />. Size [n x 1].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned is fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Single})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Computes eigenvalues and eigenvectors of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. Default: (null) do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <returns>Diagonal matrix with eigenvalues of <paramref name="A" />. Size [n x n].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Single})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors of square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. If null: do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <param name="propsA">Matrix properties, on input - if specified,
            will be used to choose an advantageous path to the solution. On exit will be
            filled according to the properties of <paramref name="A" /> (symmetric | hermitian).</param>
      <param name="balance">True: permute <paramref name="A" /> in order to increase the
            numerical stability, false: do not permute <paramref name="A" />.</param>
      <returns>Eigenvalues as vector (if <paramref name="V" /> is null) or as diagonoal
            matrix (if <paramref name="V" /> was not null).</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Single})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>Depending on the parameter <paramref name="balance" /><paramref name="A" />
            will be balanced first. This includes permutations and scaling of A in order to
            improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Computes eigenvalues of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <returns>Vector of eigenvalues of <paramref name="A" />. Size [n x 1].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned is fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Computes eigenvalues and eigenvectors of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. Default: (null) do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <returns>Diagonal matrix with eigenvalues of <paramref name="A" />. Size [n x n].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors of square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. If null: do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <param name="propsA">Matrix properties, on input - if specified,
            will be used to choose an advantageous path to the solution. On exit will be
            filled according to the properties of <paramref name="A" /> (symmetric | hermitian).</param>
      <param name="balance">True: permute <paramref name="A" /> in order to increase the
            numerical stability, false: do not permute <paramref name="A" />.</param>
      <returns>Eigenvalues as vector (if <paramref name="V" /> is null) or as diagonoal
            matrix (if <paramref name="V" /> was not null).</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be fcomplex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>Depending on the parameter <paramref name="balance" /><paramref name="A" />
            will be balanced first. This includes permutations and scaling of A in order to
            improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Computes eigenvalues of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <returns>Vector of eigenvalues of <paramref name="A" />. Size [n x 1].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The vector returned is complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.complex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Computes eigenvalues and eigenvectors of general square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. Default: (null) do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <returns>Diagonal matrix with eigenvalues of <paramref name="A" />. Size [n x n].</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.complex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>
          <paramref name="A" /> is internally balanced first. This includes permutations and scaling of <paramref name="A" /> in order to improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Find eigenvalues  and eigenvectors of square matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input: square matrix, size [n x n].</param>
      <param name="V">[Optional] Output, matrix of eigenvectors of <paramref name="A" />. Size [n x n]. If null: do not compute. If not null on entry <paramref name="V" /> returns the Eigenvectors.</param>
      <param name="propsA">Matrix properties, on input - if specified,
            will be used to choose an advantageous path to the solution. On exit will be
            filled according to the properties of <paramref name="A" /> (symmetric | hermitian).</param>
      <param name="balance">True: permute <paramref name="A" /> in order to increase the
            numerical stability, false: do not permute <paramref name="A" />.</param>
      <returns>Eigenvalues as vector (if <paramref name="V" /> is null) or as diagonoal
            matrix (if <paramref name="V" /> was not null).</returns>
      <remarks>
        <para>The eigenvalues of <paramref name="A" /> are found by use of the
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
        <para>The matrices returned will be complex, since <paramref name="A" /> may be nonsymmetric. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.complex})" /> for computing real eigenvalues of symmetric matrices.</para>
        <para>Depending on the parameter <paramref name="balance" /><paramref name="A" />
            will be balanced first. This includes permutations and scaling of A in order to
            improve the conditioning of the eigenvalues.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not a square matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigGen(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Computes eigenvalues and eigenvectors (optional) of symmetric/hermitian inputs <paramref name="A" /> and <paramref name="B" />: A*V=lamda*B*V.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n].</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n].</param>
      <param name="V">[Output, optional] Returns the eigenvectors in columns (size [n x n]). Default: (null) eigenvectors are not returned.</param>
      <param name="type">[Optional] Determines the eigen problem type. Default: (null) Ax_eq_lambBx: A*V = r*B*V.</param>
      <param name="skipSymmCheck">[Optional] true: skip tests for <paramref name="A" /> and <paramref name="B" /> being hermitian. Default: false.</param>
      <returns>Vector [n] of eigenvalues or a diagonal matrix [n,n] with the eigenvalues on the main diagonal if <paramref name="V" /> is not null.</returns>
      <remarks>
        <para>This function solves the generalized eigenproblem A*V=lamda*B*V or the problem as specified by <paramref name="type" />. </para>
        <para>Eigenvectors in <paramref name="V" /> are not normalized! See details about the normalization performed by the underlying Lapack routines.</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="B" /> was not positive definite, if <paramref name="A" /> and <paramref name="B" /> was not of the same size,
            if either <paramref name="A" /> and/or <paramref name="B" /> was found not to be symmetric/hermitian, or if the algorithm did not converge. All
            exceptions will give additional error details in their exception message.</exception>
      <seealso cref="T:ILNumerics.GenEigenType" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigGen(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Computes eigenvalues and eigenvectors (optional) of symmetric/hermitian inputs <paramref name="A" /> and <paramref name="B" />: A*V=lamda*B*V.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n].</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n].</param>
      <param name="V">[Output, optional] Returns the eigenvectors in columns (size [n x n]). Default: (null) eigenvectors are not returned.</param>
      <param name="type">[Optional] Determines the eigen problem type. Default: (null) Ax_eq_lambBx: A*V = r*B*V.</param>
      <param name="skipSymmCheck">[Optional] true: skip tests for <paramref name="A" /> and <paramref name="B" /> being hermitian. Default: false.</param>
      <returns>Vector [n] of eigenvalues or a diagonal matrix [n,n] with the eigenvalues on the main diagonal if <paramref name="V" /> is not null.</returns>
      <remarks>
        <para>This function solves the generalized eigenproblem A*V=lamda*B*V or the problem as specified by <paramref name="type" />. </para>
        <para>Eigenvectors in <paramref name="V" /> are not normalized! See details about the normalization performed by the underlying Lapack routines.</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="B" /> was not positive definite, if <paramref name="A" /> and <paramref name="B" /> was not of the same size,
            if either <paramref name="A" /> and/or <paramref name="B" /> was found not to be symmetric/hermitian, or if the algorithm did not converge. All
            exceptions will give additional error details in their exception message.</exception>
      <seealso cref="T:ILNumerics.GenEigenType" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{System.Single},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigGen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Computes eigenvalues and eigenvectors (optional) of symmetric/hermitian inputs <paramref name="A" /> and <paramref name="B" />: A*V=lamda*B*V.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n].</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n].</param>
      <param name="V">[Output, optional] Returns the eigenvectors in columns (size [n x n]). Default: (null) eigenvectors are not returned.</param>
      <param name="type">[Optional] Determines the eigen problem type. Default: (null) Ax_eq_lambBx: A*V = r*B*V.</param>
      <param name="skipSymmCheck">[Optional] true: skip tests for <paramref name="A" /> and <paramref name="B" /> being hermitian. Default: false.</param>
      <returns>Vector [n] of eigenvalues or a diagonal matrix [n,n] with the eigenvalues on the main diagonal if <paramref name="V" /> is not null.</returns>
      <remarks>
        <para>This function solves the generalized eigenproblem A*V=lamda*B*V or the problem as specified by <paramref name="type" />. </para>
        <para>Eigenvectors in <paramref name="V" /> are not normalized! See details about the normalization performed by the underlying Lapack routines.</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="B" /> was not positive definite, if <paramref name="A" /> and <paramref name="B" /> was not of the same size,
            if either <paramref name="A" /> and/or <paramref name="B" /> was found not to be symmetric/hermitian, or if the algorithm did not converge. All
            exceptions will give additional error details in their exception message.</exception>
      <seealso cref="T:ILNumerics.GenEigenType" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{ILNumerics.fcomplex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigGen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.GenEigenType,System.Boolean)">
      <summary>
            Computes eigenvalues and eigenvectors (optional) of symmetric/hermitian inputs <paramref name="A" /> and <paramref name="B" />: A*V=lamda*B*V.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Square, symmetric/hermitian input matrix, size [n x n].</param>
      <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n].</param>
      <param name="V">[Output, optional] Returns the eigenvectors in columns (size [n x n]). Default: (null) eigenvectors are not returned.</param>
      <param name="type">[Optional] Determines the eigen problem type. Default: (null) Ax_eq_lambBx: A*V = r*B*V.</param>
      <param name="skipSymmCheck">[Optional] true: skip tests for <paramref name="A" /> and <paramref name="B" /> being hermitian. Default: false.</param>
      <returns>Vector [n] of eigenvalues or a diagonal matrix [n,n] with the eigenvalues on the main diagonal if <paramref name="V" /> is not null.</returns>
      <remarks>
        <para>This function solves the generalized eigenproblem A*V=lamda*B*V or the problem as specified by <paramref name="type" />. </para>
        <para>Eigenvectors in <paramref name="V" /> are not normalized! See details about the normalization performed by the underlying Lapack routines.</para>
        <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV respectively.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="B" /> was not positive definite, if <paramref name="A" /> and <paramref name="B" /> was not of the same size,
            if either <paramref name="A" /> and/or <paramref name="B" /> was found not to be symmetric/hermitian, or if the algorithm did not converge. All
            exceptions will give additional error details in their exception message.</exception>
      <seealso cref="T:ILNumerics.GenEigenType" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eigSymm(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{ILNumerics.complex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Double})">
      <summary>
            Find all eigenvalues of symmetric / hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />).</param>
      <returns>Array of size [n,1] with eigenvalues of <paramref name="A" /> in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric the eigenvalues and the array returned have the same real/complex element type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Double},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Find all eigenvalues and -vectors of a symmetric /hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />).</param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If <paramref name="V" />
            is null on input, the eigenvectors will not be computed.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of <paramref name="A" /> on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric, eigenvalues are real. The return value will be of the same real/complex type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by (1 based) index of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by value of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Single})">
      <summary>
            Find all eigenvalues of symmetric / hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />).</param>
      <returns>Array of size [n,1] with eigenvalues of <paramref name="A" /> in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions ssyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric the eigenvalues and the array returned have the same real/fcomplex element type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Find all eigenvalues and -vectors of a symmetric /hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />).</param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If <paramref name="V" />
            is null on input, the eigenvectors will not be computed.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of <paramref name="A" /> on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions ssyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric, eigenvalues are real. The return value will be of the same real/fcomplex type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by (1 based) index of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions ssyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by value of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions ssyevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues of symmetric / hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />).</param>
      <returns>Array of size [n,1] with eigenvalues of <paramref name="A" /> in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions cheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric the eigenvalues and the array returned have the same real/fcomplex element type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Find all eigenvalues and -vectors of a symmetric /hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />).</param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If <paramref name="V" />
            is null on input, the eigenvectors will not be computed.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of <paramref name="A" /> on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions cheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric, eigenvalues are real. The return value will be of the same real/fcomplex type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by (1 based) index of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions cheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Single,System.Single)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by value of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for fcomplex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions cheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues of symmetric / hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />).</param>
      <returns>Array of size [n,1] with eigenvalues of <paramref name="A" /> in ascending order.</returns>
      <remarks>
        <para>For computation the Lapack functions zheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric the eigenvalues and the array returned have the same real/complex element type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Find all eigenvalues and -vectors of a symmetric /hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />).</param>
      <param name="V">Output: n eigenvectors in ascending order as columns. Size [n x n]. If <paramref name="V" />
            is null on input, the eigenvectors will not be computed.</param>
      <returns>Diagonal matrix of size [n,n] with eigenvalues of <paramref name="A" /> on the main diagonal.</returns>
      <remarks>
        <para>For computation the Lapack functions zheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>Since <paramref name="A" /> is symmetric, eigenvalues are real. The return value will be of the same real/complex type as <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Int32,System.Int32)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by (1 based) index of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions zheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Double,System.Double)">
      <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix. Filter by value of eigenvalues.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex <paramref name="A" />). </param>
      <param name="V">Output: m eigenvectors as columns. Size [n x m]. If <paramref name="V" /> is null on input the eigenvectors will not be computed.</param>
      <param name="rangeStart">Determines the lower limit of the index range of eigenvalues to be returned.</param>
      <param name="rangeEnd">Determines the upper limit of the index range of eigenvalues to be returned.</param>
      <returns>Diagonal matrix of size [n,m] with eigenvalues of <paramref name="A" /> on the main diagonal if <paramref name="V" /> is requested. Otherwise a vector with the first m elements being the requested eigenvalues.</returns>
      <remarks>
        <para>For computation the Lapack functions zheevr, ssyevr, chesvr and zheesv are used.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> is not square or <paramref name="rangeEnd" /> &lt; <paramref name="rangeStart" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.empty(System.Int32[])">
      <summary>
            Create array with a size determined by <paramref name="dims" /> and uninitialized elements of type <see cref="T:System.Double" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>New array, having the number and lengths of dimensions as specified by <paramref name="dims" /> and and all uninitialized elements.</returns>
      <seealso cref="P:ILNumerics.Settings.ArrayStyle" />
      <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64[])">
      <summary>
            Creates a new array of uninitialized values with a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="size">Variable length <see cref="T:System.Array" /> or comma separated list with lengths of the dimensions of the new array.</param>
      <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order, uninitialized values.</returns>
      <remarks>
        <para>
          <paramref name="size" /> cannot be <c>null</c>. Its lengths determines the number of dimensions of the new array. The elements
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
        <para>This overload creates uninitialized arrays in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> for
            determining the storage order explicitly.</para>
        <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> instead to provide the dimension lengths.
            This is recommended when high-performance is important.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
      <exception cref="T:System.ArgumentException">if <paramref name="size" /> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions" /> or contains negative values.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1">
      <summary>
            Create empty array with 0 elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of the array returned.</typeparam>
      <returns>Empty array with smallest possible number of dimensions and 0 elements.</returns>
      <remarks>
        <para>If the current array style is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> (default)
            the array returned will have the size [0,1].</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="P:ILNumerics.Settings.ArrayStyle" />
      <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)" />
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="order">[Optional] Storage order. Default: (null) means <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Create 1D array of arbitrary size without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="size">Length of dimensions.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty``1(ILNumerics.Size,ILNumerics.StorageOrders)">
      <summary>
            Create an empty array of the same size (shape) as another array without clearing the elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="size">Size descriptor of the other array A, as acquired by A.S.</param>
      <param name="order">[Optional] Storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />. This setting overrides the storage order of <paramref name="size" />.</param>
      <returns>Array as specified.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.empty">
      <summary>
            Create empty array with 0 elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of the array returned.</typeparam>
      <returns>Empty array with smallest possible number of dimensions and 0 elements.</returns>
      <remarks>
        <para>If the current array style is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> (default)
            the array returned will have the size [0,1].</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="P:ILNumerics.Settings.ArrayStyle" />
      <seealso cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,ILNumerics.StorageOrders)" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eq(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Elementwise 'EqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Boolean" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eqnan(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eqnan(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eqnan(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.eqnan(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'Equal' comparison operator on two arrays. Compares NaN and Inf like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.errorFunction(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, -1.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NaN</c>, double.NaN will be returned at that element.</item>
          <item>If </item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.errorFunctionComplement(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates of the complementary (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function">Wikipedia - Complementary Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>The value of the complementary error function at the given point <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of x is <c>xi == double.PositiveInfinity</c>, 0.0 will be returned at that element.</item>
          <item>If any element of x is <c>xi == double.NegativeInfinity</c>, +2.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.errorFunctionInverse(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the inverse of the (Gauss) error function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Error_function#Inverse_functions">Wikipedia - Inverse Error function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <returns>The value of the inverse error function at the given point <paramref name="x" />.</returns>
            &gt;
            
            <remarks><list type="bullet"><item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item><item>If <paramref name="x" /> is empty, an empty array will be returned.</item><item>If any element of x is <c>xi &gt;= +1.0</c>, double.PositiveInfinity will be returned at that element.</item><item>If any element of x is <c>xi &lt;= -1.0</c>, double.NegativeInfinity will be returned at that element.</item></list><para>[ILNumerics Computing Engine]</para></remarks></member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Raise power of <c>e</c>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Raise power of <c>e</c>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:ILNumerics.complex.Exp(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.BaseArray{System.Single})">
      <summary>
Raise power of <c>e</c>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:System.Math.Exp(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.exp(ILNumerics.BaseArray{System.Double})">
      <summary>
Raise power of <c>e</c>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with <c>e</c> raised to the power as given by A's array elements. See: <see cref="M:System.Math.Exp(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye(System.Int32,System.Int32)">
      <summary>
            Creates a new matrix with element type <see cref="T:System.Double" /> having diagonal values of 1.0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows to create.</param>
      <param name="columns">Number of columns to create.</param>
      <returns>Unity matrix (diagonal matrix) of type double, column major storage.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye``1(System.Int32,System.Int32)">
      <summary>
            Create unity matrix, arbitrary numeric type.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows.</param>
      <param name="columns">Number of columns.</param>
      <returns>Unity matrix (diagonal matrix) of element type T.</returns>
      <typeparam name="T">Element type, must derive from <see cref="T:System.ValueType" /> and <see cref="T:System.IConvertible" />.</typeparam>
      <exception cref="T:System.ArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye``1(``0,System.Int32,System.Int32,ILNumerics.StorageOrders)">
      <summary>
            Creates a diagonal matrix, arbitrary value type, diagonal value and storage order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="diagVal">The value to be assigned to all diagonal elements of the returned matrix.</param>
      <param name="rows">Number of rows to create.</param>
      <param name="columns">Number of columns to create.</param>
      <param name="order">[Optional] The storage order for the matrix returned. Default: ColumnMajor.</param>
      <returns>Matrix of element type <typeparamref name="T" /> having the element <paramref name="diagVal" /> on the main diagonal.</returns>
      <typeparam name="T">Element type, must be a value type.</typeparam>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye(System.Int64,System.Int64)">
      <summary>
            Creates a new matrix with element type <see cref="T:System.Double" /> having diagonal values of 1.0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows to create.</param>
      <param name="columns">Number of columns to create.</param>
      <returns>Unity matrix (diagonal matrix) of type double, column major storage.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye``1(System.Int64,System.Int64)">
      <summary>
            Create unity matrix, arbitrary numeric type.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows">Number of rows.</param>
      <param name="columns">Number of columns.</param>
      <returns>Unity matrix (diagonal matrix) of element type T.</returns>
      <typeparam name="T">Element type, must derive from <see cref="T:System.ValueType" /> and <see cref="T:System.IConvertible" />.</typeparam>
      <exception cref="T:System.ArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.eye``1(``0,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a diagonal matrix, arbitrary value type, diagonal value and storage order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="diagVal">The value to be assigned to all diagonal elements of the returned matrix.</param>
      <param name="rows">Number of rows to create.</param>
      <param name="columns">Number of columns to create.</param>
      <param name="order">[Optional] The storage order for the matrix returned. Default: ColumnMajor.</param>
      <returns>Matrix of element type <typeparamref name="T" /> having the element <paramref name="diagVal" /> on the main diagonal.</returns>
      <typeparam name="T">Element type, must be a value type.</typeparam>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.factorial(ILNumerics.InArray{System.Int32})">
      <summary>
Factorial, from an array of integer elements.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Factorial">Wikipedia - Factorial</a>.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the factorial of each element.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array <paramref name="n" /> is negative, the result will be double.NaN.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.factorialLog(ILNumerics.InArray{System.Int32})">
      <summary>
Natural logarithm of factorial, from an array of integer elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="n">Input array of non-negative integers.</param>
      <returns>An array of same size as <paramref name="n" /> with the natural logarithm of factorials of each element in <paramref name="n" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If the input array is empty, an empty array will be returned.</item>
          <item>If an element of the array is negative, the result will be double.NaN.</item>
          <item>If the factorial of an element of the array is infinity, the result will be infinity.</item>
          <item>If the input array is null, an ArgumentNullException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.InArray{System.Single},System.Nullable{System.UInt32})">
      <summary>
            Fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input data array.</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The output array returned will be fcomplex  hermitian. I.e. the real
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected by ILNumerics at startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{System.UInt32})">
      <summary>
            Fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.InArray{System.Double},System.Nullable{System.UInt32})">
      <summary>
            Fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input data array.</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The output array returned will be complex hermitian. I.e. the real
            part being even and the imaginary part being odd symmetrical.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected by ILNumerics at startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft(ILNumerics.InArray{ILNumerics.complex},System.Nullable{System.UInt32})">
      <summary>
            Fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{ILNumerics.complex},System.UInt32,System.UInt32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{System.Single})">
      <summary>
            Fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input array.</param>
      <returns>Complex array with transformation result.</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton dimensions. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be fcomplex  hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected at ILNumerics startup and accessible via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex source array.</param>
      <returns>Complex array with transformation result.</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton dimensions. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL (included), AMD ACML
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{System.Single},System.UInt32,System.UInt32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, fcomplex  hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{System.Double})">
      <summary>
            Fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real input array.</param>
      <returns>Complex array with transformation result.</returns>
      <remarks>
        <para>The 2D transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton dimensions. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The output array returned will be complex hermitian.</para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected at ILNumerics startup and accessible via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex source array.</param>
      <returns>Complex array with transformation result.</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton dimensions. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically selected at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL (included), AMD ACML
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fft2(ILNumerics.InArray{System.Double},System.UInt32,System.UInt32)">
      <summary>
            Fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the A array) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Double})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Int64})">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Int64})">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is smaller then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Double},System.UInt32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.complex},System.UInt32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is smaller then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Single})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result, fcomplex  hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Int64})">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, fcomplex  hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Int64})">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is smaller then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{System.Single},System.UInt32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter, fcomplex  hermitian</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.fftn(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32[])">
      <summary>
            Fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Tnput array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is smaller then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt64})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int64},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int64})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt32})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int32},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int32})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.UInt16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.UInt16})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Int16},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Int16})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Byte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Byte})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.SByte},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.SByte})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{ILNumerics.complex},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{ILNumerics.complex})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Single})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Single},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Single})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Find true elements in n-d array and give their sequential index (column major order).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source logical array.</param>
      <returns>Sequential indices of the true-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64})">
      <summary>
            Find sequential indices of <c>true</c> elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of <c>true</c> elements to find. Default: (0) find all <c>true</c> elements.</param>
      <returns>Sequential, column major ordered indices of the <c>true</c>-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> is not null on entry it contains the column indices of <c>true</c> values when the function returns. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices. </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            corresponds to the indices of the rows of <c>true</c> values if <paramref name="C" /> is not null and to sequential indices of those
            <c>true</c> values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            starts searching for <c>true</c> values from the last element and proceeds in column major order to the first element or until <paramref name="n" /><c>true</c> elements were found, if more than <paramref name="n" /><c>true</c> elements are contained in <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Double})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find. Default: (0) find all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int64" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt64})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int64})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt32})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int32})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.UInt16})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Int16})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Byte})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.SByte})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{ILNumerics.complex})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Single})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Single})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Double})">
      <summary>
            Finds sequential indices of non-zero elements in n-d array, search from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>Sequential indices of the non-zero-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})">
      <summary>
            Find sequential indices of non-zero elements in n-d array, searches from start to end in column major order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of non-zero elements to find32. Default: (0) find32 all non-zero elements.</param>
      <param name="V">[Optional] Return the found non-zero element values in <paramref name="V" />. Default: (null) don't return the values.</param>
      <returns>Sequential, column major ordered indices of the non-zero-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> or <paramref name="V" /> are not null on entry they are filled with the requested respective
            info as column vectors. If <paramref name="C" /> is not null it contains the column indices of non-zero values. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices of <paramref name="A" /> (column major order). </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})" />
            corresponds to the indices of the rows of non-zero values if <paramref name="C" /> is not null and to sequential indices of those
            non-zero values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find32(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32},ILNumerics.OutArray{System.Double})" />
            starts searching for non-zero values from the last element and proceeds in column major order to the first element or until <paramref name="n" />
            non-zero elements were found, whatever comes first.</para>
        <para>Find() returns and considers indices as 64 bit <see cref="T:System.Int32" />. Overloads exist for backwards compatibility which expect indices as <see cref="T:System.Int32" />
            values. Such functions are decorated with the suffix '32' in their names.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Find true elements in n-d array and give their sequential index (column major order). Assumes <![CDATA[<paramref name="A"/>.S.NumberOfElements < uint.MaxValue]]>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source logical array.</param>
      <returns>Sequential indices of the true-valued elements in <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.find32(ILNumerics.BaseArray{System.Boolean},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int32})">
      <summary>
            Find sequential indices of <c>true</c> elements in n-d array, searches from start to end in column major order. Assumes <![CDATA[<paramref name="A"/>.S.NumberOfElements < uint.MaxValue]]>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <param name="backwards">[Optional] Search direction backwards. Default: (false) start at the first element and search to the last element of <paramref name="A" />.</param>
      <param name="C">[Optional] If non-null on entry: the function returns the row indices and gives column indices in <paramref name="C" />. Default: (null) the function returns the sequential indices of elements found only.</param>
      <param name="n">[Optional] Maximum number of <c>true</c> elements to find. Default: (0) find all <c>true</c> elements.</param>
      <returns>Sequential, column major ordered indices of the <c>true</c>-valued elements in <paramref name="A" /> or row indices if <paramref name="C" /> is not null.</returns>
      <remarks>
        <para>If <paramref name="C" /> is not null on entry it is filled with the column indices of <c>true</c> values as column vector. If <paramref name="A" />
            has more than two dimensions subsequent dimensions are merged into the second dimension and the indices given in <paramref name="C" />
            are considered sequential indices. </para>
        <para>Note, that the array returned by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            corresponds to the indices of the rows of <c>true</c> values if <paramref name="C" /> is not null and to sequential indices of those
            <c>true</c> values if <paramref name="C" /> is null. </para>
        <para>Negative values of <paramref name="n" /> are considered as abs(n).</para>
        <para>If <paramref name="backwards" /> is true <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.find(ILNumerics.BaseArray{System.Double},System.Int64,System.Boolean,ILNumerics.OutArray{System.Int64},ILNumerics.OutArray{System.Double})" />
            starts searching for <c>true</c> values from the last element and proceeds in column major order to the first element or until <paramref name="n" /><c>true</c> elements were found, if more than <paramref name="n" /><c>true</c> elements are contained in <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Round elements towards zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards zero.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Round elements towards zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards zero.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.BaseArray{System.Single})">
      <summary>
Round elements towards zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards zero.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.fix(ILNumerics.BaseArray{System.Double})">
      <summary>
Round elements towards zero.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards zero.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Int64},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int64})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int64})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt64})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt64})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Int32},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int32})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int32})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt32})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt32})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Int16},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int16})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int16})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt16})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt16})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.SByte},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.SByte})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.SByte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Byte},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Double},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Double})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Boolean},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.complex})" />
    </member>
    <member name="M:ILNumerics.ILMath.flip(ILNumerics.BaseArray{System.Single},System.Int32)">
      <summary>
            Flips elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>This method is implemented for all common numeric element types, including <see cref="T:ILNumerics.complex" /> and logical arrays.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Single})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Single})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Single})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int64})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt64})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int32})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt32})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Int16})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.UInt16})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.SByte})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Double})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Double})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})" />
    </member>
    <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Flips the order of the columns of matrix <paramref name="A" />, i.e.: works along dimension #1.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the columns flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flipud(ILNumerics.BaseArray{ILNumerics.complex})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int64},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int64})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt64},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt64})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int32},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int32})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt32},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt32})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Int16},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Int16})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.UInt16},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.UInt16})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.SByte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.SByte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Double})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Double},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Double})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Byte},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Byte})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.fcomplex})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{ILNumerics.complex})" />
    </member>
    <member name="M:ILNumerics.ILMath.flipud(ILNumerics.BaseArray{System.Single})">
      <summary>
            Flips the order of the rows of matrix <paramref name="A" />, i.e.: works along dimension #0.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Array of the same size and type as <paramref name="A" /> having the rows flipped.</returns>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)" /> with a <c>dim</c> argument of 0.</para>
        <para>This function may works inplace and may returns the same instance of <paramref name="A" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.flip(ILNumerics.BaseArray{System.Single},System.Int32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.fliplr(ILNumerics.BaseArray{System.Single})" />
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Round elements towards negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Round elements towards negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.BaseArray{System.Single})">
      <summary>
Round elements towards negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.floor(ILNumerics.BaseArray{System.Double})">
      <summary>
Round elements towards negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements rounded towards negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)">
      <summary>
            Frees the handle for a memory region after use. This is for expert users in rare low-level scenarios only. Use the common array creation functions instead!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type used to acquire the handle.</typeparam>
      <param name="handle">The handle pointing to the allocated memory region.</param>
      <param name="nocache">[Optional] Determines whether the memory is being returned to the OS. Default: false - the memory is cached into a pool for quick reusing.</param>
      <param name="deviceIndex">The index of the device where the handles memory lives on. This must be the same device as the one used during allocation.</param>
      <remarks>
        <para>After having acquired the handle of a memory region on a device and having finished working with the memory make sure to release the memory
            back to the ILNumerics memory manager.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.New``1(System.UInt64,System.UInt32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.gamma(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>
        <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function is simply calculated as the exponential of the value found from the natural logarithm of Gamma function.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.gammaIncomplete(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the lower incomplete Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Incomplete_gamma_function">Wikipedia - Incomplete gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <param name="a">The parameter of Gamma.</param>
      <returns>The value of the lower incomplete Gamma function.</returns>
      <remarks>
        <list type="bullet">
          <item>If any of the input arrays is null, an ArgumentNullException will be thrown.</item>
          <item>If x is empty, an empty array will be returned.</item>
          <item>If any of the given points is NaN or Infinity an ArgumentException will be thrown.</item>
          <item>If any elements in <paramref name="x" /> is negative, an ArgumentException will be thrown.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.gammaLog(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the natural logarithm of the Gamma function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Gamma_function">Wikipedia - Gamma function</a>
            and <a href="http://mathworld.wolfram.com/LogGammaFunction.html">Wolfram MathWorld - Log Gamma function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function is evaluated.</param>
      <returns>log(gamma(<paramref name="x" />)) with <c>gamma(<paramref name="x" />) = from 0 to ∞ ∫(t^(<paramref name="x" />-1)exp(-t))dt</c>.</returns>
      <remarks>
        <list type="bullet">
          <item>The value of the Gamma function can be found simply using the exponential of the value found from the function. Example: exp(gammaLog(10.0)) will give the value of the gamma function at 10.0.</item>
          <item>In this particular implementation the positive real numbers are supported.</item>
          <item>If the given point <paramref name="x" /> is negative the return value will be double.NaN.</item>
          <item>If the given point <paramref name="x" /> is zero the return value will be double.PositiveInfinity.</item>
          <item>If any of the given points is double.NaN or double.IsInfinity is true, an ArgumentException will be thrown.</item>
          <item>If the input array is empty, an empty array will be returned.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ge(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'GreaterOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.gt(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'GreaterThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the rows of <paramref name="A" /> extended by the rows of <paramref name="B" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>The size of both arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="B" /> are null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" /> and <paramref name="B" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the rows of <paramref name="A" /> extended by the rows of <paramref name="B" /> and <paramref name="C" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <param name="C">The third array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" /> and <paramref name="C" />.</returns>
      <remarks>
        <para>The size of all arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if any of <paramref name="A" /> or <paramref name="B" />  or <paramref name="C" /> is null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" /> and/or <paramref name="B" /> and/or <paramref name="C" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the rows of <paramref name="A" /> extended by the rows of <paramref name="B" /> and <paramref name="C" /> and <paramref name="D" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <param name="C">The third array.</param>
      <param name="D">The fourth array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" /> and <paramref name="C" /> and <paramref name="D" />.</returns>
      <remarks>
        <para>The size of all arrays must match. This means that all but the dimension #1 must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if any of <paramref name="A" /> or <paramref name="B" />  or <paramref name="C" /> or <paramref name="D" /> is null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" /> and/or <paramref name="B" /> and/or <paramref name="C" /> and/or <paramref name="D" /> do not match.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{System.UInt32})">
      <summary>
            Inverse fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft(ILNumerics.InArray{ILNumerics.complex},System.Nullable{System.UInt32})">
      <summary>
            Inverse fast fourier transform along a specific dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Complex array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.InArray{ILNumerics.complex},System.UInt32,System.UInt32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex source array.</param>
      <returns>Complex array with the inverse transformation of <paramref name="A" />.</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The data to be transformed (based on the array A) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Inverse fast 2D discrete fourier transform.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex source array.</param>
      <returns>Complex array with the inverse transformation of <paramref name="A" />.</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.InArray{ILNumerics.complex},System.UInt32,System.UInt32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. The
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of complex hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Inverse, 2D, discrete fast fourier transform (hermitian input).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Real array with the inverse transformation of fcomplex , hermitian <paramref name="A" />.</returns>
      <remarks>
        <para>Since a transform of fcomplex  hermitian input data results in the
            output having the imaginary part equal to zero, only the real part is
            returned for efficiency reasons.</para>
        <para>One way to create a hermitian array is to (forward) transform a real array.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (within
            round-off errors), the result will be incorrect!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries.
            </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32,System.UInt32)">
      <summary>
            Inverse fast fourier transform (2D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
      <param name="m">Transformation column length</param>
      <param name="n">Transformation row length</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. The
            lengths of those trailing dimensions are not altered.</para>
        <para>Since a transform of fcomplex  hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The data to be transformed (based on the array A) are resized according to
            the length parameter m and n. If m or n is larger then the length of the corresponding
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if n or m is negative. In versions greater
            than 4.12 the API changed to <see cref="T:System.UInt32" /> length paramters, making this exception obsolete.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Inverse, 2D, discrete fast fourier transform (hermitian input).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain)</param>
      <returns>Real array with the inverse transformation of complex, hermitian <paramref name="A" />.</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in the
            output having the imaginary part equal to zero, only the real part is
            returned for efficiency reasons.</para>
        <para>One way to create a hermitian array is to (forward) transform a real array.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (within
            round-off errors), the result will be incorrect!</para>
        <para>The transformation is computed for the first 2 dimensions, regardless
            of those dimensions being singleton or non-singleton. If A is an n-d array,
            the transformation is repeated for trailing dimensions of A respectively. </para>
        <para>The two dimensional transformation is equivalent to repeatedly transforming
            the columns and after that transforming the rows of A. However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details on how to tune/configure and select dedicated native libraries.
            </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Int64})">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.complex},System.UInt32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Int64})">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32[])">
      <summary>
            Inverse fast fourier transform (n-D, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result of size specified by 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Int64})">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.complex},System.UInt32[])">
      <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of complex hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Inverse fast fourier transform (n-D)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, n-D, fcomplex  hermitian (frequency domain)</param>
      <returns>Transformation result</returns>
      <remarks>
        <para>The n-dimensional inverse transformation is computed for the n-dimensional array A.
            This is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of fcomplex  hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Int64})">
      <summary>
            Inverse fast fourier transform (n-D, fcomplex  hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of fcomplex  hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.InArray{ILNumerics.fcomplex},System.UInt32[])">
      <summary>
            Inverse fast fourier transform (n-D, fcomplex  hermitian, specific size)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array, n-D</param>
      <param name="dims">Transformation lengths, specifies the length of the dimensions
            for the transformation array. The length of dims must be &gt; or equal to  the number of
            dimensions of A. For elements in dim being smaller than corresponding dimension
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
      <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
      <remarks>
        <para>The n-dimensional transformation is computed for the n-dimensional array A.
            Before the transform, the input is resized according to the 'dims' parameter.
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
        <para>The n-dimensional transformation is equivalent to repeatedly (inplace)
            computing one dimensional transformations along all dimensions of A.
            However, using this
            function may be of magnitudes faster than using 1D transformations. This
            depends on the algorithm and API provided by the underlying native library.</para>
        <para>Since a transform of fcomplex  hermitian input data results in the
            output having the imaginary part equals zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be wrong!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries. </para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">is thrown if the
            dim parameter is null, its length is less then the number of dimensions of A
            or any element of dims is non-negative</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{System.UInt32})">
      <summary>
            Inverse fast fourier transform from fcomplex  hermitian input to real data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain).</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Real array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>Since a transform of fcomplex  hermitian input data results in an
            output having the imaginary part equal to zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be incorrect!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL (included), AMD ACML
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.InArray{ILNumerics.complex},System.Nullable{System.UInt32})">
      <summary>
            Inverse fast fourier transform from complex hermitian input to real data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex hermitian input array (frequency domain).</param>
      <param name="dim">[Optional] The working dimension. Default: (null) first non-singleton dimension of <paramref name="A" /> or dimension #0.</param>
      <returns>Real array of the same size than <paramref name="A" />.</returns>
      <remarks>
        <para>Since a transform of complex hermitian input data results in an
            output having the imaginary part equal to zero, only the real part is
            returned for convenience reasons.</para>
        <para>No check is made for A being hermitian! If A is not hermitian (by means
            of round-off errors), the result will be incorrect!</para>
        <para>The forward fourier transform and the inverse fourier transform of
            a given data array A are mathematically equivalent. It's only a
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That
            scaling is introduced in the inverse transform.</para>
        <para>The transformation is computed by use of the native library
            which currently is set up for your processor and OS version. The underlying
            library is automatically choosen at ILNumerics startup and accessed via the
            static member ILMath.FFT. See the online documentation for more
            details in how to tune/configure and select dedicated native libraries.
            Currently supported libraries are: Intel MKL (included), AMD ACML
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.imag(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Creates array with imaginary parts of complex elements from <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex input array.</param>
      <returns>Array of the same shape and size as <paramref name="A" /> with only the imaginary parts.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.imag(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Creates array with imaginary parts of complex elements from <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex input array.</param>
      <returns>Array of the same shape and size as <paramref name="A" /> with only the imaginary parts.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)">
      <summary>
            Computes dimensional indices from squential indices.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The input array providing the size, strides and element type to compute subscript indices for.</param>
      <param name="indices">Sequential ('linear') indices into <paramref name="A" />. n elements of arbitrary shape.</param>
      <param name="nrOutDims">[Optional] Number of subscript dimensions. Default: (-1) <paramref name="A" />.S.NumberOfDimensions.</param>
      <returns>A matrix [m, n], where m = <c><paramref name="indices" />.S.NumberOfElements</c> and n = <c>A.S.NumberOfDimensions</c>. Indices
            for each dimension are stored in columns.</returns>
      <remarks>
        <para>This function converts sequential element indices into subscript indices. Subscript indices specify the position of an
            element in <paramref name="A" /> by giving the position of the element in each dimension individually. Hence, n subscript indices are
            required to describe the element position in <paramref name="A" />. In contrast to that, sequential indices specify the position of an
            element in <paramref name="A" /> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index
            is than simply the index of the element in the line.</para>
        <para>The (virtual) lining-up of the elements in <paramref name="A" /> is performed in column major order. Note,
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" /> is not related to the actual order
            of the elements as they are stored in memory.</para>
        <para>If <paramref name="indices" /> is not a vector its elements are read in column major order.</para>
        <para>If the optional parameter <paramref name="nrOutDims" /> is positive it specifies the number of output subscript dimensions to compute.
            This number can differ from the actual number of dimensions in <paramref name="A" />. If <paramref name="nrOutDims" /> is smaller than the
            number of dimensions in <paramref name="A" /> unspecified trailing dimensions of <paramref name="A" /> are virtually merged and the last
            column of subscript indices holds the indices into those merged dimension. Note, that in order to use these indices to address elements
            of <paramref name="A" /> subarray indexing must be performed in <see cref="P:ILNumerics.Settings.ArrayStyle" /> = <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.</para>
        <para>If <paramref name="nrOutDims" /> is larger than <c><paramref name="A" />.S.NumberOfDimensions</c> then subscripts in columns
            corresponding to virtual dimensions of <paramref name="A" /> will be '0'.</para>
        <para>The matrix returned gives the subscripts for each element index in <paramref name="indices" /> in rows. The matrix stores m rows of
            subscripts, corresponding to m elements in <paramref name="indices" />.</para>
        <para>
          <paramref name="indices" /> can contain values addressing non-existing elements in <paramref name="A" /> (indices out-of-range).
            These indices will produce out-of-range subscript indices also. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> they may be used to grow the
            size of an array in a left-side index expression. <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            does not give an error for out-of-range elements nor for negative values in <paramref name="indices" />! The special meaning of latter (i.e.:
            counting from the end) is not considered here.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives
            the original data.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> has less than 1 dimension.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="indices" /> are null.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.UInt32},System.Int32)">
      <summary>
            Computes dimensional indices from squential indices.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The input array providing the size, strides and element type to compute subscript indices for.</param>
      <param name="indices">Sequential ('linear') indices into <paramref name="A" />. n elements of arbitrary shape.</param>
      <param name="nrOutDims">[Optional] Number of subscript dimensions. Default: (-1) <paramref name="A" />.S.NumberOfDimensions.</param>
      <returns>A matrix [m, n], where m = <c><paramref name="indices" />.S.NumberOfElements</c> and n = <c>A.S.NumberOfDimensions</c>. Indices
            for each dimension are stored in columns.</returns>
      <remarks>
        <para>This function converts sequential element indices into subscript indices. Subscript indices specify the position of an
            element in <paramref name="A" /> by giving the position of the element in each dimension individually. Hence, n subscript indices are
            required to describe the element position in <paramref name="A" />. In contrast to that, sequential indices specify the position of an
            element in <paramref name="A" /> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index
            is than simply the index of the element in the line.</para>
        <para>The (virtual) lining-up of the elements in <paramref name="A" /> is performed in column major order. Note,
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" /> is not related to the actual order
            of the elements as they are stored in memory.</para>
        <para>If <paramref name="indices" /> is not a vector its elements are read in column major order.</para>
        <para>If the optional parameter <paramref name="nrOutDims" /> is positive it specifies the number of output subscript dimensions to compute.
            This number can differ from the actual number of dimensions in <paramref name="A" />. If <paramref name="nrOutDims" /> is smaller than the
            number of dimensions in <paramref name="A" /> unspecified trailing dimensions of <paramref name="A" /> are virtually merged and the last
            column of subscript indices holds the indices into those merged dimension. Note, that in order to use these indices to address elements
            of <paramref name="A" /> subarray indexing must be performed in <see cref="P:ILNumerics.Settings.ArrayStyle" /> = <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.</para>
        <para>If <paramref name="nrOutDims" /> is larger than <c><paramref name="A" />.S.NumberOfDimensions</c> then subscripts in columns
            corresponding to virtual dimensions of <paramref name="A" /> will be '0'.</para>
        <para>The matrix returned gives the subscripts for each element index in <paramref name="indices" /> in rows. The matrix stores m rows of
            subscripts, corresponding to m elements in <paramref name="indices" />.</para>
        <para>
          <paramref name="indices" /> can contain values addressing non-existing elements in <paramref name="A" /> (indices out-of-range).
            These indices will produce out-of-range subscript indices also. In <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> they may be used to grow the
            size of an array in a left-side index expression. <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            does not give an error for out-of-range elements nor for negative values in <paramref name="indices" />! The special meaning of latter (i.e.:
            counting from the end) is not considered here.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives
            the original data.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> has less than 1 dimension.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="indices" /> are null.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.isempty(ILNumerics.BaseArray)">
      <summary>
            Tests if <paramref name="A" /> has no elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>True if <paramref name="A" /> has no elements, false otherwise.</returns>
      <remarks>
        <para>This function is an alias for <see cref="P:ILNumerics.BaseArray.IsEmpty" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="P:ILNumerics.BaseArray.IsEmpty" />
      <seealso cref="P:ILNumerics.Size.NumberOfElements" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isnullorempty(ILNumerics.BaseArray)" />
    </member>
    <member name="M:ILNumerics.ILMath.isequal(ILNumerics.BaseArray,ILNumerics.BaseArray)">
      <summary>
            Compares the number, shape, and type of elements of <paramref name="A" /> and <paramref name="B" /> and returns true if both are the same.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">First input array.</param>
      <param name="B">Second input array.</param>
      <returns>True, if all elements and sizes of both arrays match; false otherwise.</returns>
      <remarks>
        <para>Binary comparison is used on the elements. For floating point elements slight round-off
            errors will cause the comparison to fail! Use <![CDATA['allall(abs(A - B) &lt; tol)']]> or similar for floating point
            arrays instead. The same is recommended when performance is a critical factor: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isequal(ILNumerics.BaseArray,ILNumerics.BaseArray)" />
            (just like the underlying function <see cref="M:ILNumerics.BaseArray.Equals(System.Object)" />) does not parallelize automatically and is recommended
            for simple, non-performance critical comparisons only.</para>
        <para>If both arrays differ only in singleton dimensions but the types and (binary) values of all corresponding
            elements are equal the comparison can still succeed. Consider using <see cref="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)" /> additionally
            for a stricter comparisons including singleton dimensions.</para>
        <para>This function is an alias for <see cref="M:ILNumerics.BaseArray.Equals(System.Object)" /> which overrides <see cref="M:System.Object.Equals(System.Object)" />.
            In difference to latter the function does not perform reference comparison but the type and value of the elements are
            compared too.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.BaseArray.Equals(System.Object)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.allall(ILNumerics.BaseArray{System.Boolean})" />
      <seealso cref="M:ILNumerics.Size.IsSameShape(ILNumerics.Size)" />
      <seealso cref="M:ILNumerics.Size.IsSameSize(ILNumerics.Size)" />
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Checks if all elements of two arrays are equal, comparing NaN and +/- infinity like regular values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="B">Input array</param>
      <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.BaseArray{System.Double})">
      <summary>
Checks for non-infinity, non-NaN elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Checks for finite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Checks for finite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.BaseArray{System.Single})">
      <summary>
Checks for finite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as A with 'true' element where elements in A are finite.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{System.Double})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{System.Byte})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{System.Int64})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{System.Int32})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.InArray{System.Single})">
      <summary>
            Determines if matrix <paramref name="A" /> is a hermitian matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if A is a hermitian matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if A was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{System.Double})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{System.Byte})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{System.Int64})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{System.Int32})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.InArray{System.Single})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{System.Double})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{System.Byte})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{System.Int64})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{System.Int32})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.InArray{System.Single})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper Hessenberg matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper Hessenberg matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Checks for infinite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> equal +/-infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Checks for infinite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> equal +/-infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.BaseArray{System.Single})">
      <summary>
Checks for infinite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> equal +/-infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isinf(ILNumerics.BaseArray{System.Double})">
      <summary>
Checks for infinite elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> equal +/-infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Checks for elements which are not a number (NaN).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> are NaN.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Checks for elements which are not a number (NaN).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> are NaN.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.BaseArray{System.Single})">
      <summary>
Checks for elements which are not a number (NaN).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> are NaN.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnan(ILNumerics.BaseArray{System.Double})">
      <summary>
Checks for elements which are not a number (NaN).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> are NaN.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Checks for elements which correspond to negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Checks for elements which correspond to negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.BaseArray{System.Single})">
      <summary>
Checks for elements which correspond to negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.BaseArray{System.Double})">
      <summary>
Checks for elements which correspond to negative infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' negative infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnull(ILNumerics.BaseArray)">
      <summary>
            Determine, if the array A is null (NULL, not assigned).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>True, if the array is null, false otherwise</returns>
      <remarks>This function is basically the same as <see cref="M:System.Object.Equals(System.Object)" />. The difference is that memory management is performed on A.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isnullorempty(ILNumerics.BaseArray)">
      <summary>
            Tests if <paramref name="A" /> is null (NULL or not assigned) or has no elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>True if <paramref name="A" /> is null or empty, false otherwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.BaseArray{System.Single})">
      <summary>
Checks for elements which correspond to positive infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' positive infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Single})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Single})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Single})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Single})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.BaseArray{System.Double})">
      <summary>
Checks for elements which correspond to positive infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' positive infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{System.Double})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{System.Double})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{System.Double})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{System.Double})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Checks for elements which correspond to positive infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' positive infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.fcomplex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.fcomplex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Checks for elements which correspond to positive infinity.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical array of the same size as <paramref name="A" /> with 'true' element where elements in <paramref name="A" /> 'equal' positive infinity.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>
          <b>Handling NaN elements</b> The functions <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isfinite(ILNumerics.BaseArray{ILNumerics.complex})" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isinf(ILNumerics.BaseArray{ILNumerics.complex})" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isposinf(ILNumerics.BaseArray{ILNumerics.complex})" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.isneginf(ILNumerics.BaseArray{ILNumerics.complex})" /> return false for NaN (not a number)
            special floating point value elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{System.Double})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{System.Byte})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{System.Int64})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{System.Int32})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.InArray{System.Single})">
      <summary>
            Determines if matrix <paramref name="A" /> is a lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix of numeric element type.</param>
      <returns>true if <paramref name="A" /> is a lower triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{System.Double})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{System.Byte})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{System.Int64})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{System.Int32})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.istriup(ILNumerics.InArray{System.Single})">
      <summary>
            Determines if matrix <paramref name="A" /> is an upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Matrix or scalar array <paramref name="A" />, numeric element type.</param>
      <returns>true if <paramref name="A" /> is an upper triangular matrix, false otherwise.</returns>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> was null or not a matrix.</exception>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.le(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'LowerOrEqual' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.length(ILNumerics.BaseArray)">
      <summary>
            Gives the length of the longest dimension of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>The lengths of the longest dimension as system scalar type.</returns>
      <remarks>This function is the same as <see cref="P:ILNumerics.Size.Longest" />. Memory management is performed on <paramref name="A" />.
            <para>For numpy scalars (0 dimensions) 1 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="P:ILNumerics.Size.Longest" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Solves a system of linear equations, B = A x.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>Depending on the structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<double> A = randn<double>(4,4); // construct 4 x 4 matrix
            Array<double> B = vector<double>(1.0,2.0,3.0);
            Array<double> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system than solved with the result.</item><item>otherwise, if <paramref name="A" /> is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed when this function returns.
            The reason is that most functionality is performed in native LAPACK routines which require a certain storage layout (mostly
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Double},System.Nullable{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Solves a system of linear equations, B = Ax, taking hints for the best algorithm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <param name="props">[Input, Output] Known / determined matrix properties of <paramref name="A" />.</param>
      <param name="throwException">[Optional] Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> was found to
            be singular or a specific property in <paramref name="props" /> could not be confirmed. Default: true.</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>If no specific properties of <paramref name="A" /> are given in <paramref name="props" /> and
            depending on the actual structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<double> A = randn<double>(4,4); // construct 4 x 4 matrix
            Array<double> B = vector<double>(1.0,2.0,3.0);
            Array<double> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system is than solved with the triangular result.</item><item>otherwise, if <paramref name="A" />' is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>Specifying known properties of <paramref name="A" /> in <paramref name="props" /> may saves some time in
            determining these properties. If, for example, <paramref name="A" /> is known to be positive
            definite, providing <see cref="F:ILNumerics.MatrixProperties.PositivDefinite" /> allows the algorithm to
            perform cholesky factorization with <paramref name="A" />. However,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" /> determines advantageous
            properties automatically if required.</para>
        <para>After returning the <paramref name="props" /> structure can be inspected fo the matrix properties of
            <paramref name="A" /> found during the computations. Any bits changed in <paramref name="props" /> by the
            function reflect the path taken within <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />.
            However, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" /> does not determine <i>all</i>
            properties of <paramref name="A" /> automatically. If, let's say: <paramref name="A" /> is found to be singular,
            the function returns (or throws an exception) without determining further properties of A. In order to query specific
            properties of <paramref name="A" /> other functionality may be more appropriate.</para>
        <para>If <paramref name="throwException" /> is false inspecting the <paramref name="props" /> structure on return is
            required to verify that a valid solution has been computed. If <paramref name="A" /> was found to be singular and
            <paramref name="throwException" /> is false then <paramref name="props" /> will have the <see cref="F:ILNumerics.MatrixProperties.Singular" />
            flag set. If the computation was performed by QR decomposition for a non-square matrix <paramref name="A" /> then
            the <see cref="F:ILNumerics.MatrixProperties.RankDeficient" /> flag may be set.</para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed
            by this function. The reason is that most functionality is performed in native LAPACK routines which
            require a certain storage layout (mostly <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />). Be prepared that
            both arrays may point to different memory regions for element storage afterwards! This does not, however,
            affect the handling of the array with common high level functionality (subarrays, element access etc.).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Double},System.Nullable{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Solves a system of linear equations, B = A x.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>Depending on the structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<float> A = randn<float>(4,4); // construct 4 x 4 matrix
            Array<float> B = vector<float>(1.0,2.0,3.0);
            Array<float> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system than solved with the result.</item><item>otherwise, if <paramref name="A" /> is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed when this function returns.
            The reason is that most functionality is performed in native LAPACK routines which require a certain storage layout (mostly
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Single},System.Nullable{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Solves a system of linear equations, B = Ax, taking hints for the best algorithm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <param name="props">[Input, Output] Known / determined matrix properties of <paramref name="A" />.</param>
      <param name="throwException">[Optional] Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> was found to
            be singular or a specific property in <paramref name="props" /> could not be confirmed. Default: true.</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>If no specific properties of <paramref name="A" /> are given in <paramref name="props" /> and
            depending on the actual structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<float> A = randn<float>(4,4); // construct 4 x 4 matrix
            Array<float> B = vector<float>(1.0,2.0,3.0);
            Array<float> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system is than solved with the triangular result.</item><item>otherwise, if <paramref name="A" />' is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>Specifying known properties of <paramref name="A" /> in <paramref name="props" /> may saves some time in
            determining these properties. If, for example, <paramref name="A" /> is known to be positive
            definite, providing <see cref="F:ILNumerics.MatrixProperties.PositivDefinite" /> allows the algorithm to
            perform cholesky factorization with <paramref name="A" />. However,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" /> determines advantageous
            properties automatically if required.</para>
        <para>After returning the <paramref name="props" /> structure can be inspected fo the matrix properties of
            <paramref name="A" /> found during the computations. Any bits changed in <paramref name="props" /> by the
            function reflect the path taken within <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />.
            However, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" /> does not determine <i>all</i>
            properties of <paramref name="A" /> automatically. If, let's say: <paramref name="A" /> is found to be singular,
            the function returns (or throws an exception) without determining further properties of A. In order to query specific
            properties of <paramref name="A" /> other functionality may be more appropriate.</para>
        <para>If <paramref name="throwException" /> is false inspecting the <paramref name="props" /> structure on return is
            required to verify that a valid solution has been computed. If <paramref name="A" /> was found to be singular and
            <paramref name="throwException" /> is false then <paramref name="props" /> will have the <see cref="F:ILNumerics.MatrixProperties.Singular" />
            flag set. If the computation was performed by QR decomposition for a non-square matrix <paramref name="A" /> then
            the <see cref="F:ILNumerics.MatrixProperties.RankDeficient" /> flag may be set.</para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed
            by this function. The reason is that most functionality is performed in native LAPACK routines which
            require a certain storage layout (mostly <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />). Be prepared that
            both arrays may point to different memory regions for element storage afterwards! This does not, however,
            affect the handling of the array with common high level functionality (subarrays, element access etc.).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Single},System.Nullable{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Solves a system of linear equations, B = A x.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>Depending on the structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<fcomplex> A = randn<fcomplex>(4,4); // construct 4 x 4 matrix
            Array<fcomplex> B = vector<fcomplex>(1.0,2.0,3.0);
            Array<fcomplex> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system than solved with the result.</item><item>otherwise, if <paramref name="A" /> is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed when this function returns.
            The reason is that most functionality is performed in native LAPACK routines which require a certain storage layout (mostly
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Solves a system of linear equations, B = Ax, taking hints for the best algorithm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <param name="props">[Input, Output] Known / determined matrix properties of <paramref name="A" />.</param>
      <param name="throwException">[Optional] Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> was found to
            be singular or a specific property in <paramref name="props" /> could not be confirmed. Default: true.</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>If no specific properties of <paramref name="A" /> are given in <paramref name="props" /> and
            depending on the actual structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<fcomplex> A = randn<fcomplex>(4,4); // construct 4 x 4 matrix
            Array<fcomplex> B = vector<fcomplex>(1.0,2.0,3.0);
            Array<fcomplex> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system is than solved with the triangular result.</item><item>otherwise, if <paramref name="A" />' is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>Specifying known properties of <paramref name="A" /> in <paramref name="props" /> may saves some time in
            determining these properties. If, for example, <paramref name="A" /> is known to be positive
            definite, providing <see cref="F:ILNumerics.MatrixProperties.PositivDefinite" /> allows the algorithm to
            perform cholesky factorization with <paramref name="A" />. However,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" /> determines advantageous
            properties automatically if required.</para>
        <para>After returning the <paramref name="props" /> structure can be inspected fo the matrix properties of
            <paramref name="A" /> found during the computations. Any bits changed in <paramref name="props" /> by the
            function reflect the path taken within <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />.
            However, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" /> does not determine <i>all</i>
            properties of <paramref name="A" /> automatically. If, let's say: <paramref name="A" /> is found to be singular,
            the function returns (or throws an exception) without determining further properties of A. In order to query specific
            properties of <paramref name="A" /> other functionality may be more appropriate.</para>
        <para>If <paramref name="throwException" /> is false inspecting the <paramref name="props" /> structure on return is
            required to verify that a valid solution has been computed. If <paramref name="A" /> was found to be singular and
            <paramref name="throwException" /> is false then <paramref name="props" /> will have the <see cref="F:ILNumerics.MatrixProperties.Singular" />
            flag set. If the computation was performed by QR decomposition for a non-square matrix <paramref name="A" /> then
            the <see cref="F:ILNumerics.MatrixProperties.RankDeficient" /> flag may be set.</para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed
            by this function. The reason is that most functionality is performed in native LAPACK routines which
            require a certain storage layout (mostly <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />). Be prepared that
            both arrays may point to different memory regions for element storage afterwards! This does not, however,
            affect the handling of the array with common high level functionality (subarrays, element access etc.).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Solves a system of linear equations, B = A x.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>Depending on the structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<complex> A = randn<complex>(4,4); // construct 4 x 4 matrix
            Array<complex> B = vector<complex>(1.0,2.0,3.0);
            Array<complex> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system than solved with the result.</item><item>otherwise, if <paramref name="A" /> is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed when this function returns.
            The reason is that most functionality is performed in native LAPACK routines which require a certain storage layout (mostly
            <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
      <summary>
            Solves a system of linear equations, B = Ax, taking hints for the best algorithm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix <paramref name="A" />. Size [n, q].</param>
      <param name="B">Right hand side <paramref name="B" />. Size [n, m].</param>
      <param name="props">[Input, Output] Known / determined matrix properties of <paramref name="A" />.</param>
      <param name="throwException">[Optional] Throws an <see cref="T:System.ArgumentException" /> if <paramref name="A" /> was found to
            be singular or a specific property in <paramref name="props" /> could not be confirmed. Default: true.</param>
      <returns>Solution x solving the equation <c>multiply(A, x) = B</c>. Size [q, m].</returns>
      <remarks>
        <para>If no specific properties of <paramref name="A" /> are given in <paramref name="props" /> and
            depending on the actual structure and properties of <paramref name="A" /> the equation system is solved with different approaches:
            <list type="bullet"><item>If <paramref name="A" /> is square (q == n) and an <b>upper or lower triangular</b> matrix, the
            system is solved via backward- or forward substitution and the LAPACK function ?trtrs.
            <example><code><![CDATA[Array<complex> A = randn<complex>(4,4); // construct 4 x 4 matrix
            Array<complex> B = vector<complex>(1.0,2.0,3.0);
            Array<complex> x = linsolve(A,B);]]></code></example></item><item><para>if <paramref name="A" /> is square, symmetric /hermitian and positive definite <paramref name="A" /> is
            decomposed into a triangular equation system using cholesky factorization and solved via back-/ forward
            substitution.</para></item><item>otherwise, if <paramref name="A" /> is only square it will be decomposed into upper and lower triangular matrices using
            LU decomposition and the system is than solved with the triangular result.</item><item>otherwise, if <paramref name="A" />' is [n, q] with q != n, the system is solved using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex})" />
            decomposition. Note that <paramref name="A" /> can be rank deficient.</item></list></para>
        <para>Specifying known properties of <paramref name="A" /> in <paramref name="props" /> may saves some time in
            determining these properties. If, for example, <paramref name="A" /> is known to be positive
            definite, providing <see cref="F:ILNumerics.MatrixProperties.PositivDefinite" /> allows the algorithm to
            perform cholesky factorization with <paramref name="A" />. However,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" /> determines advantageous
            properties automatically if required.</para>
        <para>After returning the <paramref name="props" /> structure can be inspected fo the matrix properties of
            <paramref name="A" /> found during the computations. Any bits changed in <paramref name="props" /> by the
            function reflect the path taken within <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />.
            However, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" /> does not determine <i>all</i>
            properties of <paramref name="A" /> automatically. If, let's say: <paramref name="A" /> is found to be singular,
            the function returns (or throws an exception) without determining further properties of A. In order to query specific
            properties of <paramref name="A" /> other functionality may be more appropriate.</para>
        <para>If <paramref name="throwException" /> is false inspecting the <paramref name="props" /> structure on return is
            required to verify that a valid solution has been computed. If <paramref name="A" /> was found to be singular and
            <paramref name="throwException" /> is false then <paramref name="props" /> will have the <see cref="F:ILNumerics.MatrixProperties.Singular" />
            flag set. If the computation was performed by QR decomposition for a non-square matrix <paramref name="A" /> then
            the <see cref="F:ILNumerics.MatrixProperties.RankDeficient" /> flag may be set.</para>
        <para>The internal storage order of <paramref name="A" /> and/or <paramref name="B" /> may be silently changed
            by this function. The reason is that most functionality is performed in native LAPACK routines which
            require a certain storage layout (mostly <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />). Be prepared that
            both arrays may point to different memory regions for element storage afterwards! This does not, however,
            affect the handling of the array with common high level functionality (subarrays, element access etc.).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />
      <seealso cref="P:ILNumerics.Size.StorageOrder" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Lower triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via forward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for matrices of known, matching properties since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located above the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="F:System.Double.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Lower triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via forward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for matrices of known, matching properties since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located above the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="F:System.Single.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Lower triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via forward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for matrices of known, matching properties since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located above the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="P:ILNumerics.fcomplex.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, lower triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Lower triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via forward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for matrices of known, matching properties since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located above the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="P:ILNumerics.complex.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Upper triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via backward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for known, matching matrices, since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located below the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="F:System.Double.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Upper triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via backward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for known, matching matrices, since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located below the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="F:System.Single.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Upper triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via backward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for known, matching matrices, since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located below the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="P:ILNumerics.fcomplex.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32@)">
      <summary>
            Solve system of linear equations A*x = B, with <paramref name="A" /> being a square, upper triangular matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [n,n]. Upper triangular. No check is made for that!</param>
      <param name="B">Right hand side vector /matrix. Size [n,m].</param>
      <param name="singularityDetect">[Output] This value gives the row of <paramref name="A" />,
            where a singularity has been detected (if any). If <paramref name="A" /> is not singular, this will return a negative value.</param>
      <returns>Solution x solving <paramref name="A" /> * x = <paramref name="B" />. Size [n,m].</returns>
      <remarks>
        <para>The solution is determined via backward substitution by using a native LAPACK module.</para>
        <para>Make sure, <paramref name="A" /> and <paramref name="B" /> are of correct size, since no checks are made for that!</para>
        <para>This function is used by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />. It can speed
            up the computation for known, matching matrices, since it saves some checks on them which are otherwise automatically
            performed by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linsolve(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)" />.</para>
        <para>Any elements of <paramref name="A" /> located below the main diagonal will be ignored.</para>
        <para>If <paramref name="A" /> is singular the array returned contains <see cref="P:ILNumerics.complex.NaN" /> values.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0})">
      <summary>
            Create linearly spaced row vector of 100 elements
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First value</param>
      <param name="end">Last value</param>
      <returns>Row vector with 100 elements linearly spaced between start and end</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})">
      <summary>
            Create linearly spaced row vector, generic element type.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First value, scalar, numeric</param>
      <param name="end">Last value, scalar, numeric</param>
      <param name="length">Number of elements to create, scalar, numeric</param>
      <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
      <remarks>
        <para>
          <see cref="F:linspace{T}(InArray{T}, InArray{T}, InArray{T})" /> returns an empty array if <paramref name="length" /> is 0.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" /> returns a scalar array with the value of <paramref name="end" /> if <paramref name="length" /> is 1.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Create linearly spaced row vector, double precision.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">The first value.</param>
      <param name="end">The last value.</param>
      <param name="length">Number of elements to create.</param>
      <returns>Vector with 'length' elements linearly spaced between start and end.</returns>
      <remarks>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" /> returns an empty array if <paramref name="length" /> is 0.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" /> returns a scalar array with the value of <paramref name="end" /> if <paramref name="length" /> is 1.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadArray``1(System.String,System.String)">
      <summary>
            Load single array from matfile file.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type of the array to read.</typeparam>
      <param name="filename">Path to the matfile.</param>
      <param name="arrayname">[Optional] name of the requested array in the matfile. Default: (empty) load the first array found.</param>
      <returns>The array read from matfile.</returns>
      <remarks>
        <para>If <paramref name="arrayname" /> is ommited, the first array is returned.</para>
        <para>This function is based on <see cref="T:ILNumerics.MatFile" /> which works with Matlab mat files version 6 only.
            In order to access Matlab mat files of a newer version, use the <see cref="N:ILNumerics.IO.HDF5" /> API.</para>
        <para>The typeparameter <typeparamref name="T" /> must match the type of elements stored in the mat file.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="T:ILNumerics.MatFile" />
      <seealso cref="N:ILNumerics.IO.HDF5" />
    </member>
    <member name="M:ILNumerics.ILMath.loadBinary``1(System.IO.Stream,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.IntPtr,System.IntPtr,System.Int64})">
      <summary>
            Load binary data from stream.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="stream">Input stream to read from.</param>
      <param name="leadDimLen">Length of the 'leading dimension', how many elements of T fit into one scanline?</param>
      <param name="height">Height of the area to read.</param>
      <param name="width">Widht of the area to read.</param>
      <param name="offsetWidth">[Optional] Skip that many columns. Default: 0.</param>
      <param name="offsetHeight">[Optional] Skip that many rows. Default: 0.</param>
      <param name="convertScanLine">[Optional] Function used for copying individual scanlines. Default: null (Buffer.BlockCopy). Parameters: dest*, src*, nrBytes.</param>
      <returns>Array with element type <typeparamref name="T" /> and given size with a binary copy of the region as read from <paramref name="stream" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="filename">Path to image file to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="inputStream">Image stream with image data to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadChannels(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load ARGB pixel data from image, provide indiviudal channel data.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="image">Image to read pixels from.</param>
      <param name="rect">[Optional] Rectangular area to read. Default: full image size.</param>
      <returns>Array of element type byte, of image size height x width x 4. Channel data are distributed along the 3rd dimension in ARGB order.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.String,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image file.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="filename">Image filename.</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are
            accumulated in the single element. Each channel is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb" />. If you get unexpected results,
            make sure that the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.IO.Stream,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image stream.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="inputStream">Image data as stream.</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned.
            All channels are accumulated in the single element. Each channel is represented by 8 bits in the
            32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make
            sure, the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.loadArray``1(System.String,System.String)" />
    </member>
    <member name="M:ILNumerics.ILMath.loadImage(System.Drawing.Image,System.Nullable{System.Drawing.Rectangle})">
      <summary>
            Load pixel data from image.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="image">The image.</param>
      <param name="rect">[Optional] Rectangular area in the image to read data from. Default: the whole image is read.</param>
      <returns>Image pixel data as Int32 elements</returns>
      <remarks>
        <para>Each pixel in the image is converted to a single element in the array returned. All channels are accumulated in the single element. Each channel
            is represented by 8 bits in the 32 bits of each Int32 element.</para>
            The image data are considered as PixelFormat.Format32bppArgb. If you get unexpected results, make sure, the image is provided in a compatible format.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.localCell">
      <summary>
            Create new empty cell array, used for cell class member (attributes) initialization.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty logical cell array to be assigned to a local <see cref="T:ILNumerics.Cell" /> variable.</returns>
      <remarks>The array returned is an empty cell array. Its only purpose is to serve as an initialization
            for a local variable <see cref="T:ILNumerics.Cell" /> as attributes in a class context. The array will not
            be disposed after leaving the current scope or any scope above the current scope. It is useful
            for initializing class attributes in a persistant manner. After initialization, use the
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMath.localLogical">
      <summary>
            Create new empty logical array, used for logical class member (attributes) initialization.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <returns>Empty logical array to be assigned to a local <see cref="T:ILNumerics.Logical" /> variable.</returns>
      <remarks>The array returned is an empty array. Its only purpose is to serve as an initialization
            for a local variable <see cref="T:ILNumerics.Logical" /> as attributes in a class context. The array will not
            be disposed after leaving the current scope or any scope above the current scope. It is useful
            for initializing class attributes in a persistant manner. After initialization, use the
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMath.localMember``1">
      <summary>
            Initialize a local array variable as class attribute / field.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <returns>Empty array to be assigned to a local <see cref="T:ILNumerics.Array`1" /> variable.</returns>
      <remarks>The array returned is an empty array. Its only purpose is to serve as an initialization
            for a local variable <see cref="T:ILNumerics.Array`1" /> as attributes in a class context. The array will not
            be disposed after leaving the current scope or any scope above the current scope. It is useful
            for initializing class attributes in a persistant manner. After initialization, use the
            'Array.a = ...' property (C#) or the Array.Assign() function to assign new values to the array.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso href="http://ilnumerics.net/ClassRules.html" />
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Logarithm of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Logarithm of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.BaseArray{System.Single})">
      <summary>
Logarithm of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log(ILNumerics.BaseArray{System.Double})">
      <summary>
Logarithm of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Base 10 logarithm of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Base 10 logarithm of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.BaseArray{System.Single})">
      <summary>
Base 10 logarithm of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10(ILNumerics.BaseArray{System.Double})">
      <summary>
Base 10 logarithm of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10c(ILNumerics.BaseArray{System.Single})">
      <summary>
Base 10 logarithm of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10c(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.log10c(ILNumerics.BaseArray{System.Double})">
      <summary>
Base 10 logarithm of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of log10c(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logc(ILNumerics.BaseArray{System.Single})">
      <summary>
Logarithm of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of logc(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logc(ILNumerics.BaseArray{System.Double})">
      <summary>
Logarithm of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of logc(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logical(System.Boolean[],ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates a new logical array from the values provided in <paramref name="values" /> with the shape given by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="values">Values to be copied to the new ILNumerics array.</param>
      <param name="size">The size of the new ILNumerics array. Number of elements must correspond to the number of values in <paramref name="values" />.</param>
      <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</param>
      <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
      <remarks>A copy is made from <paramref name="values" />. The array <paramref name="values" /> is not referenced
            by ILNumerics after the function returns.
            <para>Make sure that the number of elements configured by the dimension lengths in <paramref name="size" />
            matches the number of elements in <paramref name="values" />.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <example>
        <code><![CDATA[Assert.IsTrue(logical(new[] { true }, size(1)) == true);]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.logical(ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders},System.Boolean)">
      <summary>
            Creates a new logical array with given shape and optional storage order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">The size of the new array.</param>
      <param name="order">[Optional] Storage order for the new ILNumerics array. Default: (<see cref="P:ILNumerics.Settings.DefaultStorageOrder" />).</param>
      <param name="clear">[Optional] True: initialize the elements of the new logical with value 'False'. Default: true.</param>
      <returns>A new ILNumerics array with copies of the given values and the given shape.</returns>
      <remarks>
        <para>Use this function to create and optionally initialize (large) logicals from scratch, outside of a binary operation and without
            converting from a .NET array of booleans.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <example>
        <code><![CDATA[Logical L = logical(size(1000,2000), StorageOrders.RowMajor);]]></code>
      </example>
    </member>
    <member name="M:ILNumerics.ILMath.logistic(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the sigmoid logistic function at a given point.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logistic_function">Wikipedia - Logistic function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">The point where the function will be evaluated.</param>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.PositiveInfinity</c>, +1.0 will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == double.NegativeInfinity</c>, 0.0 will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <returns>The value of the logistic function at the given point <paramref name="x" />.</returns>
    </member>
    <member name="M:ILNumerics.ILMath.logit(ILNumerics.InArray{System.Double})">
      <summary>
            Evaluates the inverse of the sigmoid logistic function.
            For more details about this function, see <a href="http://en.wikipedia.org/wiki/Logit_function">Wikipedia - Logit function</a>.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="x">point defined between 0 and 1.</param>
      <returns>The logarithm of <paramref name="x" /> divided by 1.0 - <paramref name="x" />.</returns>
      <remarks>
        <list type="bullet">
          <item>If <paramref name="x" /> is null, an ArgumentNullException will be thrown.</item>
          <item>If <paramref name="x" /> is empty, an empty array will be returned.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≥ 1.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi ≤ 0.0</c>, double.NaN will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 1.0</c>, double.PositiveInfinity will be returned at that element.</item>
          <item>If any element of <paramref name="x" /> is <c>xi == 0.0</c>, double.NegativeInfinity will be returned at that element.</item>
        </list>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector of 50 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First exponent value.</param>
      <param name="end">Last exponent value.</param>
      <returns>Row vector with 50 elements logarithmically spaced between 10<sup>start</sup> and 10<sup>end</sup>.</returns>
      <remarks>
        <para>If <paramref name="end" /> equals <see cref="P:ILNumerics.Globals.pi" /> than the upper interval for the
            values returned is π and the range is: [10^start...π]</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.logspace(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Create logarithmically spaced row vector
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">First exponent value</param>
      <param name="end">Last exponent value</param>
      <param name="length">Number of elements to create</param>
      <returns>Row vector with 'length' elements logarithmically spaced between 10<sup>start</sup> and 10<sup>end</sup>.</returns>
      <remarks>
        <para>If <paramref name="end" /> equals <see cref="P:ILNumerics.Globals.pi" /> than the upper interval for the
            values returned is π and the range is: [10^start...π]</para>
        <para>If <paramref name="length" /> is 1 than a single value of 10<sup>end</sup> is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lshift(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftLeft.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lt(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'LowerThan' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            LU matrix decomposition. Decompose general matrix <paramref name="A" /> into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n].</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strictly upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mostly needed for further operations via Lapack libraries. If you need the
            L and U matrices directly, consider using the overload
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> instead.</para>
        <para>lu uses the Lapack function ?getrf, which is provided by a native LAPACK implementation (mostly Intel's MKL).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
      <exception cref="T:System.ArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Decompose matrix <paramref name="A" /> into uper and lower triangular matrices. Also generates pivoting permutation matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="U">[Output] Upper triangular matrix. Size [min(m,n) x n]. This can be null.</param>
      <param name="P">[Output, optional] Permutation matrix <paramref name="P" />. Size [m x m]. Default: (null) do not compute the permutation matrix. L is ordered propery before the function returns.</param>
      <returns>Lower triangular matrix L. Size [m x min(m,n)].</returns>
      <remarks>
        <para>
          <paramref name="A" /> is decomposed into L and <paramref name="U" /> so that the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds within the range of round off errors.</para>
        <para>The matrix L returned is a lower triangular matrix with unit diagonal. Depending on <paramref name="P" /> the rows
            of L may be reordered due to pivoting during the triangulation. If <paramref name="P" /> is not null on entry (i.e.:
            the permutation matrix <paramref name="P" /> is computed and returned from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />) L
            is truely lower triangular. In this case the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds. Note, that the result of matrix multiplying L with <paramref name="U" />
            yields a version of <paramref name="A" /> having its rows reordered. <paramref name="P" /> permutes the rows of <paramref name="A" /> accordingly.
            Note further, that <paramref name="P" /> is suitable to be multiplied
            to <paramref name="A" />, while some other systems return <paramref name="P" /><sup>-1</sup> for reordering the result L**<paramref name="U" /> instead.</para>
        <para>If <paramref name="P" /> is null on entry (i.e.: the permutation matrix <paramref name="P" /> is not requested and thus not returned) any
            permutation performed in the triangulation is reversed before returning L so that the matrix L returned is not guranteed to be lower triangular. Instead,
            the rows of L are reordered by P<sup>-1</sup>**L. In this case the simplified equation <c>ILMath.multiply(L,U) == ILMath.multiply(A)</c> holds (default). </para>
        <para>
          <paramref name="U" /> is a strictly upper triangular matrix. Any permutation is performed on L and not on <paramref name="U" />. Thus, the order of rows of
            <paramref name="U" /> does not depend on <paramref name="P" />.</para>
        <example><![CDATA[
            <code>
            // Construct a matrix A:
            Array<complex> A = new complex[,]{
            {1, 2, 3},
            {4, 4, 4},
            {5, 6, 7}
            };
            // A
            // <Double> [3x3] order: -
            //(:,:)
            // 1    2    3
            // 4    4    4
            // 5    6    7
            //
            // define arrays serving as output arrays for U and P
            Array<complex> U = 1, P = 1;
            Array<complex> L = ILMath.lu(A, U, P);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //            1          0          0
            //     0,800000          1          0
            //     0,200000  -1,000000          1
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            //P
            //<Double> [3,3] 0...0 order:|
            //            0          0          1
            //            0          1          0
            //            1          0          0
            </code>]]>
            L and U are triangular matrices. P is returned as well. The result of L**U gives:
            <code>
            multiply(L,U)
            5          6          7
            4          4          4
            1          2          3
            </code>
            This result matches a reordered version of A, which can be computed by help of P:
            multiply(P,A)
            5          6          7
            4          4          4
            1          2          3
            </example>
        <example>
            // Computing the LU factorization of A without returning the permutation matrix P:
            <![CDATA[<code>
            L = lu(A,U);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //   0,200000  -1,000000          1
            //   0,800000          1          0
            //          1          0          0
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            </code>]]>
            This time, while U did not change, L is not triangular but a reordered version of a lower triangular matrix. However,
            multiplying L ** U gives A directly:
            <![CDATA[<code>
            
            multiply(L,U)
            1          2          3
            4          4          4
            5          6          7
            </code>]]></example>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>The input matrix <paramref name="A" /> is not altered.</para>
        <para>Either of <paramref name="U" /> and/or <paramref name="P" /> can be null on entry. If <paramref name="U" />
            is null the upper triangular matrix will be computed but not returned. Instead, the compressed form of L
            and <paramref name="U" /> is returned as created by the LAPACK function ?getrf:
            </para>
        <para>
          <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        </para>
        <para>If <paramref name="P" /> is null on entry and <paramref name="U" /> is not null the permutation matrix is not computed but rows of L are reordered accordingly in order to fullfill the equation 'A = L**U'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{ILNumerics.complex},System.Boolean)" />
      <seealso cref="T:ILNumerics.Core.Native.ILapack" />
      <exception cref="T:System.ArgumentException"> if input <paramref name="A" /> is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{System.Double})">
      <summary>
            LU matrix decomposition. Decompose general matrix <paramref name="A" /> into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n].</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strictly upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mostly needed for further operations via Lapack libraries. If you need the
            L and U matrices directly, consider using the overload
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> instead.</para>
        <para>lu uses the Lapack function ?getrf, which is provided by a native LAPACK implementation (mostly Intel's MKL).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
      <exception cref="T:System.ArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Decompose matrix <paramref name="A" /> into uper and lower triangular matrices. Also generates pivoting permutation matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="U">[Output] Upper triangular matrix. Size [min(m,n) x n]. This can be null.</param>
      <param name="P">[Output, optional] Permutation matrix <paramref name="P" />. Size [m x m]. Default: (null) do not compute the permutation matrix. L is ordered propery before the function returns.</param>
      <returns>Lower triangular matrix L. Size [m x min(m,n)].</returns>
      <remarks>
        <para>
          <paramref name="A" /> is decomposed into L and <paramref name="U" /> so that the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds within the range of round off errors.</para>
        <para>The matrix L returned is a lower triangular matrix with unit diagonal. Depending on <paramref name="P" /> the rows
            of L may be reordered due to pivoting during the triangulation. If <paramref name="P" /> is not null on entry (i.e.:
            the permutation matrix <paramref name="P" /> is computed and returned from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />) L
            is truely lower triangular. In this case the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds. Note, that the result of matrix multiplying L with <paramref name="U" />
            yields a version of <paramref name="A" /> having its rows reordered. <paramref name="P" /> permutes the rows of <paramref name="A" /> accordingly.
            Note further, that <paramref name="P" /> is suitable to be multiplied
            to <paramref name="A" />, while some other systems return <paramref name="P" /><sup>-1</sup> for reordering the result L**<paramref name="U" /> instead.</para>
        <para>If <paramref name="P" /> is null on entry (i.e.: the permutation matrix <paramref name="P" /> is not requested and thus not returned) any
            permutation performed in the triangulation is reversed before returning L so that the matrix L returned is not guranteed to be lower triangular. Instead,
            the rows of L are reordered by P<sup>-1</sup>**L. In this case the simplified equation <c>ILMath.multiply(L,U) == ILMath.multiply(A)</c> holds (default). </para>
        <para>
          <paramref name="U" /> is a strictly upper triangular matrix. Any permutation is performed on L and not on <paramref name="U" />. Thus, the order of rows of
            <paramref name="U" /> does not depend on <paramref name="P" />.</para>
        <example><![CDATA[
            <code>
            // Construct a matrix A:
            Array<double> A = new double[,]{
            {1, 2, 3},
            {4, 4, 4},
            {5, 6, 7}
            };
            // A
            // <Double> [3x3] order: -
            //(:,:)
            // 1    2    3
            // 4    4    4
            // 5    6    7
            //
            // define arrays serving as output arrays for U and P
            Array<double> U = 1, P = 1;
            Array<double> L = ILMath.lu(A, U, P);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //            1          0          0
            //     0,800000          1          0
            //     0,200000  -1,000000          1
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            //P
            //<Double> [3,3] 0...0 order:|
            //            0          0          1
            //            0          1          0
            //            1          0          0
            </code>]]>
            L and U are triangular matrices. P is returned as well. The result of L**U gives:
            <code>
            multiply(L,U)
            5          6          7
            4          4          4
            1          2          3
            </code>
            This result matches a reordered version of A, which can be computed by help of P:
            multiply(P,A)
            5          6          7
            4          4          4
            1          2          3
            </example>
        <example>
            // Computing the LU factorization of A without returning the permutation matrix P:
            <![CDATA[<code>
            L = lu(A,U);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //   0,200000  -1,000000          1
            //   0,800000          1          0
            //          1          0          0
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            </code>]]>
            This time, while U did not change, L is not triangular but a reordered version of a lower triangular matrix. However,
            multiplying L ** U gives A directly:
            <![CDATA[<code>
            
            multiply(L,U)
            1          2          3
            4          4          4
            5          6          7
            </code>]]></example>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>The input matrix <paramref name="A" /> is not altered.</para>
        <para>Either of <paramref name="U" /> and/or <paramref name="P" /> can be null on entry. If <paramref name="U" />
            is null the upper triangular matrix will be computed but not returned. Instead, the compressed form of L
            and <paramref name="U" /> is returned as created by the LAPACK function ?getrf:
            </para>
        <para>
          <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        </para>
        <para>If <paramref name="P" /> is null on entry and <paramref name="U" /> is not null the permutation matrix is not computed but rows of L are reordered accordingly in order to fullfill the equation 'A = L**U'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{System.Double},System.Boolean)" />
      <seealso cref="T:ILNumerics.Core.Native.ILapack" />
      <exception cref="T:System.ArgumentException"> if input <paramref name="A" /> is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{System.Single})">
      <summary>
            LU matrix decomposition. Decompose general matrix <paramref name="A" /> into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n].</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strictly upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mostly needed for further operations via Lapack libraries. If you need the
            L and U matrices directly, consider using the overload
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> instead.</para>
        <para>lu uses the Lapack function ?getrf, which is provided by a native LAPACK implementation (mostly Intel's MKL).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
      <exception cref="T:System.ArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Decompose matrix <paramref name="A" /> into uper and lower triangular matrices. Also generates pivoting permutation matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="U">[Output] Upper triangular matrix. Size [min(m,n) x n]. This can be null.</param>
      <param name="P">[Output, optional] Permutation matrix <paramref name="P" />. Size [m x m]. Default: (null) do not compute the permutation matrix. L is ordered propery before the function returns.</param>
      <returns>Lower triangular matrix L. Size [m x min(m,n)].</returns>
      <remarks>
        <para>
          <paramref name="A" /> is decomposed into L and <paramref name="U" /> so that the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds within the range of round off errors.</para>
        <para>The matrix L returned is a lower triangular matrix with unit diagonal. Depending on <paramref name="P" /> the rows
            of L may be reordered due to pivoting during the triangulation. If <paramref name="P" /> is not null on entry (i.e.:
            the permutation matrix <paramref name="P" /> is computed and returned from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />) L
            is truely lower triangular. In this case the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds. Note, that the result of matrix multiplying L with <paramref name="U" />
            yields a version of <paramref name="A" /> having its rows reordered. <paramref name="P" /> permutes the rows of <paramref name="A" /> accordingly.
            Note further, that <paramref name="P" /> is suitable to be multiplied
            to <paramref name="A" />, while some other systems return <paramref name="P" /><sup>-1</sup> for reordering the result L**<paramref name="U" /> instead.</para>
        <para>If <paramref name="P" /> is null on entry (i.e.: the permutation matrix <paramref name="P" /> is not requested and thus not returned) any
            permutation performed in the triangulation is reversed before returning L so that the matrix L returned is not guranteed to be lower triangular. Instead,
            the rows of L are reordered by P<sup>-1</sup>**L. In this case the simplified equation <c>ILMath.multiply(L,U) == ILMath.multiply(A)</c> holds (default). </para>
        <para>
          <paramref name="U" /> is a strictly upper triangular matrix. Any permutation is performed on L and not on <paramref name="U" />. Thus, the order of rows of
            <paramref name="U" /> does not depend on <paramref name="P" />.</para>
        <example><![CDATA[
            <code>
            // Construct a matrix A:
            Array<float> A = new float[,]{
            {1, 2, 3},
            {4, 4, 4},
            {5, 6, 7}
            };
            // A
            // <Double> [3x3] order: -
            //(:,:)
            // 1    2    3
            // 4    4    4
            // 5    6    7
            //
            // define arrays serving as output arrays for U and P
            Array<float> U = 1, P = 1;
            Array<float> L = ILMath.lu(A, U, P);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //            1          0          0
            //     0,800000          1          0
            //     0,200000  -1,000000          1
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            //P
            //<Double> [3,3] 0...0 order:|
            //            0          0          1
            //            0          1          0
            //            1          0          0
            </code>]]>
            L and U are triangular matrices. P is returned as well. The result of L**U gives:
            <code>
            multiply(L,U)
            5          6          7
            4          4          4
            1          2          3
            </code>
            This result matches a reordered version of A, which can be computed by help of P:
            multiply(P,A)
            5          6          7
            4          4          4
            1          2          3
            </example>
        <example>
            // Computing the LU factorization of A without returning the permutation matrix P:
            <![CDATA[<code>
            L = lu(A,U);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //   0,200000  -1,000000          1
            //   0,800000          1          0
            //          1          0          0
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            </code>]]>
            This time, while U did not change, L is not triangular but a reordered version of a lower triangular matrix. However,
            multiplying L ** U gives A directly:
            <![CDATA[<code>
            
            multiply(L,U)
            1          2          3
            4          4          4
            5          6          7
            </code>]]></example>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>The input matrix <paramref name="A" /> is not altered.</para>
        <para>Either of <paramref name="U" /> and/or <paramref name="P" /> can be null on entry. If <paramref name="U" />
            is null the upper triangular matrix will be computed but not returned. Instead, the compressed form of L
            and <paramref name="U" /> is returned as created by the LAPACK function ?getrf:
            </para>
        <para>
          <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        </para>
        <para>If <paramref name="P" /> is null on entry and <paramref name="U" /> is not null the permutation matrix is not computed but rows of L are reordered accordingly in order to fullfill the equation 'A = L**U'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{System.Single},System.Boolean)" />
      <seealso cref="T:ILNumerics.Core.Native.ILapack" />
      <exception cref="T:System.ArgumentException"> if input <paramref name="A" /> is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            LU matrix decomposition. Decompose general matrix <paramref name="A" /> into strictly upper part and lower part.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n].</returns>
      <remarks>
        <para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strictly upper triangular matrix U.</para>
        <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        <para>This overload is mostly needed for further operations via Lapack libraries. If you need the
            L and U matrices directly, consider using the overload
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> instead.</para>
        <para>lu uses the Lapack function ?getrf, which is provided by a native LAPACK implementation (mostly Intel's MKL).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <exception cref="T:System.ArgumentException"> if input A is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.lu(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Decompose matrix <paramref name="A" /> into uper and lower triangular matrices. Also generates pivoting permutation matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="U">[Output] Upper triangular matrix. Size [min(m,n) x n]. This can be null.</param>
      <param name="P">[Output, optional] Permutation matrix <paramref name="P" />. Size [m x m]. Default: (null) do not compute the permutation matrix. L is ordered propery before the function returns.</param>
      <returns>Lower triangular matrix L. Size [m x min(m,n)].</returns>
      <remarks>
        <para>
          <paramref name="A" /> is decomposed into L and <paramref name="U" /> so that the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds within the range of round off errors.</para>
        <para>The matrix L returned is a lower triangular matrix with unit diagonal. Depending on <paramref name="P" /> the rows
            of L may be reordered due to pivoting during the triangulation. If <paramref name="P" /> is not null on entry (i.e.:
            the permutation matrix <paramref name="P" /> is computed and returned from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.lu(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />) L
            is truely lower triangular. In this case the equation
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> holds. Note, that the result of matrix multiplying L with <paramref name="U" />
            yields a version of <paramref name="A" /> having its rows reordered. <paramref name="P" /> permutes the rows of <paramref name="A" /> accordingly.
            Note further, that <paramref name="P" /> is suitable to be multiplied
            to <paramref name="A" />, while some other systems return <paramref name="P" /><sup>-1</sup> for reordering the result L**<paramref name="U" /> instead.</para>
        <para>If <paramref name="P" /> is null on entry (i.e.: the permutation matrix <paramref name="P" /> is not requested and thus not returned) any
            permutation performed in the triangulation is reversed before returning L so that the matrix L returned is not guranteed to be lower triangular. Instead,
            the rows of L are reordered by P<sup>-1</sup>**L. In this case the simplified equation <c>ILMath.multiply(L,U) == ILMath.multiply(A)</c> holds (default). </para>
        <para>
          <paramref name="U" /> is a strictly upper triangular matrix. Any permutation is performed on L and not on <paramref name="U" />. Thus, the order of rows of
            <paramref name="U" /> does not depend on <paramref name="P" />.</para>
        <example><![CDATA[
            <code>
            // Construct a matrix A:
            Array<fcomplex> A = new fcomplex[,]{
            {1, 2, 3},
            {4, 4, 4},
            {5, 6, 7}
            };
            // A
            // <Double> [3x3] order: -
            //(:,:)
            // 1    2    3
            // 4    4    4
            // 5    6    7
            //
            // define arrays serving as output arrays for U and P
            Array<fcomplex> U = 1, P = 1;
            Array<fcomplex> L = ILMath.lu(A, U, P);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //            1          0          0
            //     0,800000          1          0
            //     0,200000  -1,000000          1
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            //P
            //<Double> [3,3] 0...0 order:|
            //            0          0          1
            //            0          1          0
            //            1          0          0
            </code>]]>
            L and U are triangular matrices. P is returned as well. The result of L**U gives:
            <code>
            multiply(L,U)
            5          6          7
            4          4          4
            1          2          3
            </code>
            This result matches a reordered version of A, which can be computed by help of P:
            multiply(P,A)
            5          6          7
            4          4          4
            1          2          3
            </example>
        <example>
            // Computing the LU factorization of A without returning the permutation matrix P:
            <![CDATA[<code>
            L = lu(A,U);
            
            // L
            // <Double> [3,3] 1...1 order:|
            //   0,200000  -1,000000          1
            //   0,800000          1          0
            //          1          0          0
            //
            // U
            //<Double> [3,3] 5...1,11022302462516E-15 order:|
            //            5          6          7
            //            0  -0,800000  -1,600000
            //            0          0   0,000000
            //
            </code>]]>
            This time, while U did not change, L is not triangular but a reordered version of a lower triangular matrix. However,
            multiplying L ** U gives A directly:
            <![CDATA[<code>
            
            multiply(L,U)
            1          2          3
            4          4          4
            5          6          7
            </code>]]></example>
        <para>lu uses the Lapack function ?getrf.</para>
        <para>The input matrix <paramref name="A" /> is not altered.</para>
        <para>Either of <paramref name="U" /> and/or <paramref name="P" /> can be null on entry. If <paramref name="U" />
            is null the upper triangular matrix will be computed but not returned. Instead, the compressed form of L
            and <paramref name="U" /> is returned as created by the LAPACK function ?getrf:
            </para>
        <para>
          <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
        </para>
        <para>If <paramref name="P" /> is null on entry and <paramref name="U" /> is not null the permutation matrix is not computed but rows of L are reordered accordingly in order to fullfill the equation 'A = L**U'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.chol(ILNumerics.InArray{ILNumerics.fcomplex},System.Boolean)" />
      <seealso cref="T:ILNumerics.Core.Native.ILapack" />
      <exception cref="T:System.ArgumentException"> if input <paramref name="A" /> is not a matrix.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Boolean)">
      <summary>
            Gives the maximum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="F:System.Double.NaN" /> the other element is returned. If both elements are
            <see cref="F:System.Double.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="F:System.Double.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Gives the maximum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="P:ILNumerics.fcomplex.NaN" /> the other element is returned. If both elements are
            <see cref="P:ILNumerics.fcomplex.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="P:ILNumerics.fcomplex.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Gives the maximum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="P:ILNumerics.complex.NaN" /> the other element is returned. If both elements are
            <see cref="P:ILNumerics.complex.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="P:ILNumerics.complex.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Boolean)">
      <summary>
            Gives the maximum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="F:System.Single.NaN" /> the other element is returned. If both elements are
            <see cref="F:System.Single.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="F:System.Single.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Maximum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the maximum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the maximum for. This is not altered.</param>
      <param name="index">[Optional] index of the maximum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the maximum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the maximum values along a specific dimension. </para>
        <para>The functions 'max','min','maxall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.InArray{System.Double},System.Int32)">
      <summary>
            Mean of <paramref name="A" /> along dimension <paramref name="dim" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim" />
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Double},System.Int32)" /> operates along the first non singleton
            dimension.</param>
      <returns>Mean of elements along specified or first non singleton dimension.</returns>
      <remarks>The return array has the same shape as <paramref name="A" />, except that the
            working dimension is reduced/expanded to length 1.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
            Mean of <paramref name="A" /> along dimension <paramref name="dim" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim" />
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)" /> operates along the first non singleton
            dimension.</param>
      <returns>Mean of elements along specified or first non singleton dimension.</returns>
      <remarks>The return array has the same shape as <paramref name="A" />, except that the
            working dimension is reduced/expanded to length 1.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.InArray{System.Single},System.Int32)">
      <summary>
            Mean of <paramref name="A" /> along dimension <paramref name="dim" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim" />
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{System.Single},System.Int32)" /> operates along the first non singleton
            dimension.</param>
      <returns>Mean of elements along specified or first non singleton dimension.</returns>
      <remarks>The return array has the same shape as <paramref name="A" />, except that the
            working dimension is reduced/expanded to length 1.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mean(ILNumerics.InArray{ILNumerics.complex},System.Int32)">
      <summary>
            Mean of <paramref name="A" /> along dimension <paramref name="dim" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="dim">[Optional] Index of the dimension to operate along. If <paramref name="dim" />
            is omitted <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.mean(ILNumerics.InArray{ILNumerics.complex},System.Int32)" /> operates along the first non singleton
            dimension.</param>
      <returns>Mean of elements along specified or first non singleton dimension.</returns>
      <remarks>The return array has the same shape as <paramref name="A" />, except that the
            working dimension is reduced/expanded to length 1.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="outY">[Output, Optional]: if on entry <paramref name="outY" /> is not null it holds the values for the Y dimension on return.</param>
      <returns>X values matrix along the values of <paramref name="X" />. Corresponding values for Y are returned in <paramref name="outY" />.</returns>
      <remarks>
        <para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="Z">Vector of z values.</param>
      <param name="outY">[Output, Optional] If on entry <paramref name="outY" /> is not null it holds the values for the y dimension on return.</param>
      <param name="outZ">[Output, Optional] If on entry <paramref name="outZ" /> is not null it holds the values for the z dimension on return.</param>
      <returns>X value array along the values of <paramref name="X" />, arrays for y and z dimensions are returned in <paramref name="outY" /> and <paramref name="outZ" /> respectively.</returns>
      <remarks>
        <para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build
            a 3 dimensional grid with edges at all permutations of <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="outY">[Output, Optional]: if on entry <paramref name="outY" /> is not null it holds the values for the Y dimension on return.</param>
      <returns>X values matrix along the values of <paramref name="X" />. Corresponding values for Y are returned in <paramref name="outY" />.</returns>
      <remarks>
        <para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="Z">Vector of z values.</param>
      <param name="outY">[Output, Optional] If on entry <paramref name="outY" /> is not null it holds the values for the y dimension on return.</param>
      <param name="outZ">[Output, Optional] If on entry <paramref name="outZ" /> is not null it holds the values for the z dimension on return.</param>
      <returns>X value array along the values of <paramref name="X" />, arrays for y and z dimensions are returned in <paramref name="outY" /> and <paramref name="outZ" /> respectively.</returns>
      <remarks>
        <para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build
            a 3 dimensional grid with edges at all permutations of <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="outY">[Output, Optional]: if on entry <paramref name="outY" /> is not null it holds the values for the Y dimension on return.</param>
      <returns>X values matrix along the values of <paramref name="X" />. Corresponding values for Y are returned in <paramref name="outY" />.</returns>
      <remarks>
        <para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="Z">Vector of z values.</param>
      <param name="outY">[Output, Optional] If on entry <paramref name="outY" /> is not null it holds the values for the y dimension on return.</param>
      <param name="outZ">[Output, Optional] If on entry <paramref name="outZ" /> is not null it holds the values for the z dimension on return.</param>
      <returns>X value array along the values of <paramref name="X" />, arrays for y and z dimensions are returned in <paramref name="outY" /> and <paramref name="outZ" /> respectively.</returns>
      <remarks>
        <para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build
            a 3 dimensional grid with edges at all permutations of <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions over a 2d grid.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="outY">[Output, Optional]: if on entry <paramref name="outY" /> is not null it holds the values for the Y dimension on return.</param>
      <returns>X values matrix along the values of <paramref name="X" />. Corresponding values for Y are returned in <paramref name="outY" />.</returns>
      <remarks>
        <para>The matrices returned can conveniently be used to evaluate and visualize functions of 2 variables over a grid of (X Y) positions.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="X">Vector of x values.</param>
      <param name="Y">Vector of y values.</param>
      <param name="Z">Vector of z values.</param>
      <param name="outY">[Output, Optional] If on entry <paramref name="outY" /> is not null it holds the values for the y dimension on return.</param>
      <param name="outZ">[Output, Optional] If on entry <paramref name="outZ" /> is not null it holds the values for the z dimension on return.</param>
      <returns>X value array along the values of <paramref name="X" />, arrays for y and z dimensions are returned in <paramref name="outY" /> and <paramref name="outZ" /> respectively.</returns>
      <remarks>
        <para>The arrays returned can conveniently be used to evaluate and visualize functions of 3 variables X, Y and Z. Coordinates build
            a 3 dimensional grid with edges at all permutations of <paramref name="X" />, <paramref name="Y" /> and <paramref name="Z" />.</para>
        <para>Note that the X dimension goes along the <i>rows</i>, while the second dimension is considered the columns! This deviates from the
            common intuition and the actual storage order of matrix elements (i.e.: first dimension along the columns and 2nd dimension along the rows).
            The reason for it is the convenience this order gives for plotting purposes: In most plots the X axis is expected to run horizontaly.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="X" /> or <paramref name="Y" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Gives the minimum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="P:ILNumerics.fcomplex.NaN" /> the other element is returned. If both elements are
            <see cref="P:ILNumerics.fcomplex.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="P:ILNumerics.fcomplex.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Gives the minimum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="P:ILNumerics.complex.NaN" /> the other element is returned. If both elements are
            <see cref="P:ILNumerics.complex.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="P:ILNumerics.complex.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single},System.Boolean)">
      <summary>
            Gives the minimum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="F:System.Single.NaN" /> the other element is returned. If both elements are
            <see cref="F:System.Single.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="F:System.Single.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double},System.Boolean)">
      <summary>
            Gives the minimum of corresponding elements from <paramref name="A" /> and <paramref name="B" />. Recognizes NaN values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <param name="omitNaN">[Optional] specifies how to deal with NaN values in
            <paramref name="A" /> or <paramref name="B" />. Default: (true) prefer non-NaN values if possible.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>Handling of NaN values: <paramref name="omitNaN" /> is true (default). For floating point element types and if one of the elements to compare is
            <see cref="F:System.Double.NaN" /> the other element is returned. If both elements are
            <see cref="F:System.Double.NaN" /> the element from <paramref name="A" /> is returned.</para>
        <para>If <paramref name="omitNaN" /> is false the result is <see cref="F:System.Double.NaN" /> if at least
            one of the elements is NaN. If both elements are NaN than the first element is returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Minimum.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">The index of the dimension to be reduced.</param>
      <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para>
        <para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para>
        <para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para>
        <para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para>
        <para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)">
      <summary>
            Computes the (flattened, row-major) sequential index and value of the element with the minimum value in <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Array to compute the minimum for. This is not altered.</param>
      <param name="index">[Optional] index of the minimum value. Default: (null) the index is not returned.</param>
      <param name="order">[Optional] iteration order for the flattened sequential indices. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <param name="ignoreNaN">[Optional] determins how NaN values are handled for floating point element types. Ignored for integer elements. Defaul: (true) ignores NaNs.</param>
      <returns>Scalar array with the minimum value in A.</returns>
      <remarks>
        <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" /> for
            getting the minimum values along a specific dimension. </para>
        <para>The functions 'min','min','minall','minall' give all similar results between the framework APIs (ILNumericsV4/Matlab(R) / numpy)
            but show individual behavior regarding the handling of floating point NaN values and iteration order. The value of 'true'
            for <paramref name="ignoreNaN" /> corresponds to the behavior of ILNumerics version 4/ Matlab(R). Only if
            all elements in <paramref name="A" /> are <see cref="F:System.Single.NaN" /> the value of the result will also be NaN. This is the default.</para>
        <para>The value of 'false' for <paramref name="ignoreNaN" /> gives the numpy behavior: NaN values take precedence over non-NaN values. If
            one element in the set of values is NaN the result will also be NaN. This is the default behavior for such functions defined as
            [numpy API] extension methods on the array classes.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.mod_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Modulo.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Matrix multiplication for 3 general matrices (2D). Performs A ** (B ** C).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <param name="C">Input matrix C.</param>
      <returns>Matrix with result of <paramref name="A" /> ** (<paramref name="B" /> ** <paramref name="C" />), where ** denotes matrix multiplication.</returns>
      <remarks>
        <para>All arrays must be matrices with matching dimension length. Watch the oder of computations: <paramref name="B" /> is
            multiplied with <paramref name="C" /> first. The result is right multiplied with <paramref name="A" />. </para>
        <para>The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used. </para>
        <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of any input parameter without notice.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Matrix multiplication for general matrices (2D).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <returns>Matrix of size A.S[0] x B.S[1] with result of multiplying the matrices <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>Both arrays must be matrices with matching dimension length. This is: the number of rows
            of <paramref name="B" /> must equal the number of columns of <paramref name="A" />. </para>
            The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used.
            <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of <paramref name="A" /> and/or <paramref name="B" /> without notice.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" /> or <paramref name="B" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Matrix multiplication for 3 general matrices (2D). Performs A ** (B ** C).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <param name="C">Input matrix C.</param>
      <returns>Matrix with result of <paramref name="A" /> ** (<paramref name="B" /> ** <paramref name="C" />), where ** denotes matrix multiplication.</returns>
      <remarks>
        <para>All arrays must be matrices with matching dimension length. Watch the oder of computations: <paramref name="B" /> is
            multiplied with <paramref name="C" /> first. The result is right multiplied with <paramref name="A" />. </para>
        <para>The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used. </para>
        <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of any input parameter without notice.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Matrix multiplication for general matrices (2D).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <returns>Matrix of size A.S[0] x B.S[1] with result of multiplying the matrices <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>Both arrays must be matrices with matching dimension length. This is: the number of rows
            of <paramref name="B" /> must equal the number of columns of <paramref name="A" />. </para>
            The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used.
            <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of <paramref name="A" /> and/or <paramref name="B" /> without notice.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" /> or <paramref name="B" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Matrix multiplication for 3 general matrices (2D). Performs A ** (B ** C).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <param name="C">Input matrix C.</param>
      <returns>Matrix with result of <paramref name="A" /> ** (<paramref name="B" /> ** <paramref name="C" />), where ** denotes matrix multiplication.</returns>
      <remarks>
        <para>All arrays must be matrices with matching dimension length. Watch the oder of computations: <paramref name="B" /> is
            multiplied with <paramref name="C" /> first. The result is right multiplied with <paramref name="A" />. </para>
        <para>The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used. </para>
        <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of any input parameter without notice.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Matrix multiplication for general matrices (2D).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <returns>Matrix of size A.S[0] x B.S[1] with result of multiplying the matrices <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>Both arrays must be matrices with matching dimension length. This is: the number of rows
            of <paramref name="B" /> must equal the number of columns of <paramref name="A" />. </para>
            The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used.
            <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of <paramref name="A" /> and/or <paramref name="B" /> without notice.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" /> or <paramref name="B" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Matrix multiplication for 3 general matrices (2D). Performs A ** (B ** C).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <param name="C">Input matrix C.</param>
      <returns>Matrix with result of <paramref name="A" /> ** (<paramref name="B" /> ** <paramref name="C" />), where ** denotes matrix multiplication.</returns>
      <remarks>
        <para>All arrays must be matrices with matching dimension length. Watch the oder of computations: <paramref name="B" /> is
            multiplied with <paramref name="C" /> first. The result is right multiplied with <paramref name="A" />. </para>
        <para>The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used. </para>
        <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of any input parameter without notice.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiply(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Matrix multiplication for general matrices (2D).
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix A.</param>
      <param name="B">Input matrix B.</param>
      <returns>Matrix of size A.S[0] x B.S[1] with result of multiplying the matrices <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>Both arrays must be matrices with matching dimension length. This is: the number of rows
            of <paramref name="B" /> must equal the number of columns of <paramref name="A" />. </para>
            The multiplication will be carried out inside optimized native code, if possible. Otherwise, an optimized, blocked, managed version is used.
            <para>Be prepared that this function may alter the storage order (<see cref="P:ILNumerics.Size.StorageOrder" />) of <paramref name="A" /> and/or <paramref name="B" /> without notice.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException">If at least one of <paramref name="A" /> or <paramref name="B" /> is not a matrix or does
            not have a matching shape.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.multiplyElem_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: MultiplyElem.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ndims(ILNumerics.BaseArray)">
      <summary>
            Number of dimensions of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>If <paramref name="A" /> is null: 0. Otherwise returns the number of dimensions of <paramref name="A" />.</returns>
      <remarks>This is an alias for <see cref="P:ILNumerics.Size.NumberOfDimensions" />.<para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="P:ILNumerics.Size.NumberOfDimensions" />
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Double})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Single})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Int64})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Int32})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Int16})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.Byte})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.negate(ILNumerics.BaseArray{System.SByte})">
      <summary>
Unary negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Unary negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.neq(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Elementwise 'UnEqualTo' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Boolean" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.New``1(System.UInt64,System.UInt32,System.Boolean)">
      <summary>
            Provides memory / T[] array for the current thread. This is for expert users and rare low-level scenarios only. Use the common array creation functions instead!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type, specifies the type and size of elements.</typeparam>
      <param name="elementCount">Number of elements which must at least fit into the memory region.</param>
      <param name="deviceIndex">[Optional] Index of the device owning the memory. Default: 0 is the host device.</param>
      <param name="clear">[Optional] Flag determining whether the memory should be initialized to zero. Default: do not clear.</param>
      <returns>Memory handle to a memory region or an managed array accoring to the provided element type and device.</returns>
      <remarks>
        <para>This function supports the utilization of memory regions in a C style manner: user have to manage memory explicitly and manually.
            Instead of using this function it is recommended to use the common ILNumerics array creation functions to create and work with ILNumerics arrays.
            which do not require to create, clean up or to reuse memory manually. ILNumerics <see href="/FunctionRules.html">function rules</see> do all this automatically. Thus,
            manual memory management is left for very few special situations only.</para>
        <para>Depending on the type category the memory handle returned references one of the following memory types:
            <list type="number"><item>T is struct / ValueType: memory is allocated on the unmanaged heap. There is no inherent size limitation. Access to the memory is done
            by means of the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer" /> property. Users are responsible to correctly deal with such pointers. All risks of unsafe code apply.</item><item>T is class / reference type: the function allocates a <see cref="T:System.Array" /> on the managed heap. Access is done by first casting the memory handle
            returned to the concrete type of <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1" /> and then using the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray" /> property to acquire the T[] array.</item></list></para>
        <para>Attempting to access the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray" /> on a native handle generates an exception.</para>
        <para>Attempting to access the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer" /> on a ManagedHostHandle{T} generates an exception.</para>
        <para>MemoryHandles are critical handles. Disposal is guaranteed by critical execution regions and the GC. However, users should
            dispose the handle to free the memory region immediately after use. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)" /> for disposing memory handles.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)" />
      <exception cref="T:System.InvalidOperationException"> when trying to access either of the Pointer or the HostArray properties on handles of invalid types.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.New``1(System.Int64,System.UInt32,System.Boolean)">
      <summary>
            Provides memory / T[] array for the current thread. This is for expert users and rare low-level scenarios only. Use the common array creation functions instead!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type, specifies the type and size of elements.</typeparam>
      <param name="elementCount">Number of elements which must at least fit into the memory region.</param>
      <param name="deviceIndex">[Optional] Index of the device owning the memory. Default: 0 is the host device.</param>
      <param name="clear">[Optional] Flag determining whether the memory should be initialized to zero. Default: do not clear.</param>
      <returns>Memory handle to a memory region or an managed array accoring to the provided element type and device.</returns>
      <remarks>
        <para>This function supports the utilization of memory regions in a C style manner: user have to manage memory explicitly and manually.
            Instead of using this function it is recommended to use the common ILNumerics array creation functions to create and work with ILNumerics arrays.
            which do not require to create, clean up or to reuse memory manually. ILNumerics <see href="/FunctionRules.html">function rules</see> do all this automatically. Thus,
            manual memory management is left for very few special situations only.</para>
        <para>Depending on the type category the memory handle returned references one of the following memory types:
            <list type="number"><item>T is struct / ValueType: memory is allocated on the unmanaged heap. There is no inherent size limitation. Access to the memory is done
            by means of the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer" /> property. Users are responsible to correctly deal with such pointers. All risks of unsafe code apply.</item><item>T is class / reference type: the function allocates a <see cref="T:System.Array" /> on the managed heap. Access is done by first casting the memory handle
            returned to the concrete type of <see cref="T:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1" /> and then using the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray" /> property to acquire the T[] array.</item></list></para>
        <para>Attempting to access the <see cref="F:ILNumerics.Core.MemoryLayer.ManagedHostHandle`1.HostArray" /> on a native handle generates an exception.</para>
        <para>Attempting to access the <see cref="P:ILNumerics.Core.MemoryLayer.MemoryHandle.Pointer" /> on a ManagedHostHandle{T} generates an exception.</para>
        <para>MemoryHandles are critical handles. Disposal is guaranteed by critical execution regions and the GC. However, users should
            dispose the handle to free the memory region immediately after use. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)" /> for disposing memory handles.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.free``1(ILNumerics.Core.MemoryLayer.MemoryHandle,System.UInt32,System.Boolean)" />
      <exception cref="T:System.InvalidOperationException"> when trying to access either of the Pointer or the HostArray properties on handles of invalid types.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.InArray{System.Double},System.Double)">
      <summary>
            Vector or matrix norm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix or vector.</param>
      <param name="degree">[Optional] Degree of the norm. Default: 2.</param>
      <returns>Array of same type as input array <paramref name="A" />.</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>System.double.PositiveInfinity: returns max(abs(A))</item><item>System.double.NegativeInfinity: returns min(abs(A))</item><item>other double values: returns sum(pow(abs(A),degree))^(1/degree)</item></list>
            For matrices <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.InArray{ILNumerics.fcomplex},System.Single)">
      <summary>
            Vector or matrix norm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix or vector.</param>
      <param name="degree">[Optional] Degree of the norm. Default: 2.</param>
      <returns>Array of same type as input array <paramref name="A" />.</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>System.fcomplex.PositiveInfinity: returns max(abs(A))</item><item>System.fcomplex.NegativeInfinity: returns min(abs(A))</item><item>other fcomplex values: returns sum(pow(abs(A),degree))^(1/degree)</item></list>
            For matrices <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.InArray{System.Single},System.Single)">
      <summary>
            Vector or matrix norm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix or vector.</param>
      <param name="degree">[Optional] Degree of the norm. Default: 2.</param>
      <returns>Array of same type as input array <paramref name="A" />.</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>System.float.PositiveInfinity: returns max(abs(A))</item><item>System.float.NegativeInfinity: returns min(abs(A))</item><item>other float values: returns sum(pow(abs(A),degree))^(1/degree)</item></list>
            For matrices <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.norm(ILNumerics.InArray{ILNumerics.complex},System.Double)">
      <summary>
            Vector or matrix norm.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix or vector.</param>
      <param name="degree">[Optional] Degree of the norm. Default: 2.</param>
      <returns>Array of same type as input array <paramref name="A" />.</returns>
      <remarks>For vectors, <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0 : returns sqrt(sum(A * A))</item><item>System.complex.PositiveInfinity: returns max(abs(A))</item><item>System.complex.NegativeInfinity: returns min(abs(A))</item><item>other complex values: returns sum(pow(abs(A),degree))^(1/degree)</item></list>
            For matrices <paramref name="degree" /> must be one of:
            <list type="bullet"><item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item><item>1: returns 1-norm, max(sum(abs(A)))</item><item>2: returns the largest singular value of A, max(svd(A))</item><item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item></list><para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para><para>For empty arrays A, scalar 0 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.not(ILNumerics.BaseArray{System.Boolean})">
      <summary>
Logical negation of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical negation of array elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.numel(ILNumerics.BaseArray)">
      <summary>
            Gives the number of elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>The number of elements of <paramref name="A" /> as system scalar type.</returns>
      <remarks>This function is the same as <see cref="P:ILNumerics.Size.NumberOfElements" />. Memory management is performed on <paramref name="A" />.
            <para>For numpy scalars (0 dimensions) 1 is returned.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="P:ILNumerics.Size.Longest" />
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64)">
      <summary>
            Creates a square matrix of 1.0-valued <see cref="T:System.Double" /> elements, size [dim0, dim0].
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows_columns">Length of dimension #0 and dimension #1.</param>
      <returns>New ILNumerics array initialized with 1.0 values.</returns>
      <remarks>This creates a square matrix with the same number of rows and columns. The elements
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> order.
            <para>This function always creates a matrix, hence the array returned will always have
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle" /> allows it.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 1.0 <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <returns>New ILNumerics array initialized with 1.0.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a square matrix of 1-valued elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="rows_columns">Length of dimension #0 and dimension #1 (the number of rows and columns).</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with 1s.</returns>
      <remarks>This creates a square matrix with the same number of rows and columns. The elements
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> order.
            <para>This function always creates a matrix, hence the array returned will always have
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle" /> allows it.</para><para>Supported element types are all predefined, scalar numeric value types.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of ones for numeric element types <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with ones.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(ILNumerics.Size,ILNumerics.StorageOrders)">
      <summary>
            Creates a new array of ones '1' with the same size as <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="size">Number and lengths of the dimensions for the new array.</param>
      <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array of the specified size and storage order, initialized with '1'.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates a new array of ones '1' with a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="size">Vector with lengths of the dimensions of the new array.</param>
      <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array of the specified size and storage order, initialized with '1'.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.ones``1(System.Int64[])">
      <summary>
            Creates a new array of ones '1' with a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array. This must be a value type.</typeparam>
      <param name="size">Variable length <see cref="T:System.Array" /> or comma separated list with lengths of the dimensions of the new array.</param>
      <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order, initialized with '1'.</returns>
      <remarks>
        <para>Supported element types are all predefined, scalar numeric value types.</para>
        <para>
          <paramref name="size" /> must be not null. Its lengths determines the number of dimensions of the new array. Negative element values are not allowed.</para>
        <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> for
            determining the storage order explicitly.</para>
        <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> instead to provide the dimension lengths.
            This is recommended when high-performance is important.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
      <exception cref="T:System.ArgumentException">if <paramref name="size" /> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions" /> or contains negative values.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.or(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Elementwise 'Or' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.UInt32})">
      <summary>
            Reorder dimensions of n-dimensional array <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
      <returns>Array with reordered dimensions.</returns>
      <remarks>
        <paramref name="A" /> will not change. A new array is created, having
            the dimensions rearranged in the order specified by <paramref name="dim" />.
            <para>The length of <paramref name="dim" /> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para><para>In version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})" /> became more efficient since no
            elements must be copied for a permutation of the dimensions. The resulting array may not expose any common
            storage layout, though. Thus, subsequent operations handling the result may have to perform a copy nevertheless.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A" /> and the number of elements for the
            new dimensions specified by <paramref name="dim" /> do not match or if any index of a dimension from <paramref name="A" /> is
            missing in list of elements in <paramref name="dim" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})">
      <summary>
            Reorder dimensions of n-dimensional array <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
      <returns>Array with reordered dimensions.</returns>
      <remarks>
        <paramref name="A" /> will not change. A new array is created, having
            the dimensions rearranged in the order specified by <paramref name="dim" />.
            <para>The length of <paramref name="dim" /> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para><para>From version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64})" /> is much more efficient since no elements must
            be copied for a permutation of the dimensions.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A" /> and the number of elements for the
            new dimensions specified by <paramref name="dim" /> do not match or if any index of a dimension from <paramref name="A" /> is
            missing in list of elements in <paramref name="dim" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int32})">
      <summary>
            Reorder dimensions of n-dimensional array <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array</param>
      <param name="dim">New dimension order. The order of the zero-based indices of the original dimensions specify the target arrays shape.</param>
      <returns>Array with reordered dimensions.</returns>
      <remarks>
        <paramref name="A" /> will not change. A new array is created, having
            the dimensions rearranged in the order specified by <paramref name="dim" />.
            <para>The length of <paramref name="dim" /> must match the number of dimensions in A: <c>A.S.NumberOfDimensions == dim.Length</c>.</para><para>From version 5 <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.permute``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int32})" /> is much more efficient since no elements must
            be copied for a permutation of the dimensions.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> If the number of elements in <paramref name="A" /> and the number of elements for the
            new dimensions specified by <paramref name="dim" /> do not match or if any index of a dimension from <paramref name="A" /> is
            missing in list of elements in <paramref name="dim" />.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
      <summary>
            Moore-Penrose pseudo inverse of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="tolerance">[Optional] Tolerance. Default: (null) - use default tolerance (see remarks).</param>
      <returns>Pseudo inverse of input matrix <paramref name="A" /></returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix <paramref name="A" />. The return value will be of the same size as <paramref name="A" />.T.
            It will satisfy the following conditions:
            <list type="bullet"><item><paramref name="A" /> * pinv(<paramref name="A" />) * <paramref name="A" />  = <paramref name="A" /></item><item>pinv(<paramref name="A" />) * <paramref name="A" /> * pinv(<paramref name="A" />) = pinv(<paramref name="A" />)</item><item>pinv(<paramref name="A" />) * <paramref name="A" /> is hermitian.</item><item><paramref name="A" /> * pinv(<paramref name="A" />) is hermitian.</item></list><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Double},System.Nullable{System.Double})" /> relies on <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />, utilizing native Lapack functions internally.
            Singular values less than <paramref name="tolerance" /> will be set to zero. As default tolerance the following equation is used: \\
            <c>tolerance = length(<paramref name="A" />) * norm(<paramref name="A" />) * eps</c>, where
            <list type="bullet"><item>length(<paramref name="A" />) - the longest dimension of <paramref name="A" />.</item><item>norm(<paramref name="A" />) being the largest singular value of <paramref name="A" />.</item><item>eps - the smallest number greater than one.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Double},System.Nullable{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Double})" />
      <seealso cref="P:ILNumerics.Globals.eps" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.norm(ILNumerics.InArray{System.Double},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
      <summary>
            Moore-Penrose pseudo inverse of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="tolerance">[Optional] Tolerance. Default: (null) - use default tolerance (see remarks).</param>
      <returns>Pseudo inverse of input matrix <paramref name="A" /></returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix <paramref name="A" />. The return value will be of the same size as <paramref name="A" />.T.
            It will satisfy the following conditions:
            <list type="bullet"><item><paramref name="A" /> * pinv(<paramref name="A" />) * <paramref name="A" />  = <paramref name="A" /></item><item>pinv(<paramref name="A" />) * <paramref name="A" /> * pinv(<paramref name="A" />) = pinv(<paramref name="A" />)</item><item>pinv(<paramref name="A" />) * <paramref name="A" /> is hermitian.</item><item><paramref name="A" /> * pinv(<paramref name="A" />) is hermitian.</item></list><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Single},System.Nullable{System.Single})" /> relies on <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />, utilizing native Lapack functions internally.
            Singular values less than <paramref name="tolerance" /> will be set to zero. As default tolerance the following equation is used: \\
            <c>tolerance = length(<paramref name="A" />) * norm(<paramref name="A" />) * eps</c>, where
            <list type="bullet"><item>length(<paramref name="A" />) - the longest dimension of <paramref name="A" />.</item><item>norm(<paramref name="A" />) being the largest singular value of <paramref name="A" />.</item><item>eps - the smallest number greater than one.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{System.Single},System.Nullable{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Single})" />
      <seealso cref="P:ILNumerics.Globals.eps" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.norm(ILNumerics.InArray{System.Single},System.Single)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})">
      <summary>
            Moore-Penrose pseudo inverse of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="tolerance">[Optional] Tolerance. Default: (null) - use default tolerance (see remarks).</param>
      <returns>Pseudo inverse of input matrix <paramref name="A" /></returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix <paramref name="A" />. The return value will be of the same size as <paramref name="A" />.T.
            It will satisfy the following conditions:
            <list type="bullet"><item><paramref name="A" /> * pinv(<paramref name="A" />) * <paramref name="A" />  = <paramref name="A" /></item><item>pinv(<paramref name="A" />) * <paramref name="A" /> * pinv(<paramref name="A" />) = pinv(<paramref name="A" />)</item><item>pinv(<paramref name="A" />) * <paramref name="A" /> is hermitian.</item><item><paramref name="A" /> * pinv(<paramref name="A" />) is hermitian.</item></list><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})" /> relies on <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />, utilizing native Lapack functions internally.
            Singular values less than <paramref name="tolerance" /> will be set to zero. As default tolerance the following equation is used: \\
            <c>tolerance = length(<paramref name="A" />) * norm(<paramref name="A" />) * eps</c>, where
            <list type="bullet"><item>length(<paramref name="A" />) - the longest dimension of <paramref name="A" />.</item><item>norm(<paramref name="A" />) being the largest singular value of <paramref name="A" />.</item><item>eps - the smallest number greater than one.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.fcomplex})" />
      <seealso cref="P:ILNumerics.Globals.eps" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.norm(ILNumerics.InArray{ILNumerics.fcomplex},System.Single)" />
    </member>
    <member name="M:ILNumerics.ILMath.pinv(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})">
      <summary>
            Moore-Penrose pseudo inverse of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="tolerance">[Optional] Tolerance. Default: (null) - use default tolerance (see remarks).</param>
      <returns>Pseudo inverse of input matrix <paramref name="A" /></returns>
      <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix <paramref name="A" />. The return value will be of the same size as <paramref name="A" />.T.
            It will satisfy the following conditions:
            <list type="bullet"><item><paramref name="A" /> * pinv(<paramref name="A" />) * <paramref name="A" />  = <paramref name="A" /></item><item>pinv(<paramref name="A" />) * <paramref name="A" /> * pinv(<paramref name="A" />) = pinv(<paramref name="A" />)</item><item>pinv(<paramref name="A" />) * <paramref name="A" /> is hermitian.</item><item><paramref name="A" /> * pinv(<paramref name="A" />) is hermitian.</item></list><see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})" /> relies on <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />, utilizing native Lapack functions internally.
            Singular values less than <paramref name="tolerance" /> will be set to zero. As default tolerance the following equation is used: \\
            <c>tolerance = length(<paramref name="A" />) * norm(<paramref name="A" />) * eps</c>, where
            <list type="bullet"><item>length(<paramref name="A" />) - the longest dimension of <paramref name="A" />.</item><item>norm(<paramref name="A" />) being the largest singular value of <paramref name="A" />.</item><item>eps - the smallest number greater than one.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.pinv(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />
      <seealso cref="P:ILNumerics.Globals.eps" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.norm(ILNumerics.InArray{ILNumerics.complex},System.Double)" />
    </member>
    <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Transforms polar/ cylindrical coordinates into scalar coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="theta">Angle values to x axis.</param>
      <param name="radius">Radius values from z axis.</param>
      <param name="Z">Height coordinates.</param>
      <param name="Y">[Optional] Output: If not null on entry the Y components are returned here.</param>
      <param name="outZ">[Optional] Output: If not null on entry, the Z components are returned here.</param>
      <returns>X component values. <paramref name="Y" /> and <paramref name="Z" /> are returned as output parameter if requested.</returns>
      <remarks>
        <paramref name="theta" />, <paramref name="radius" /> and <paramref name="Z" /> must be of
            the same size or broadcastable to each other. Output arrays returned are of the same size then the broadcasted
            size of the input arrays.
            <para><paramref name="outZ" /> corresponds to <paramref name="Z" /> but has been broadcasted to the output size.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Transforms polar/ cylindrical coordinates into scalar coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="theta">Angle values to x axis.</param>
      <param name="radius">Radius values from z axis.</param>
      <param name="Z">Height coordinates.</param>
      <param name="Y">[Optional] Output: If not null on entry the Y components are returned here.</param>
      <param name="outZ">[Optional] Output: If not null on entry, the Z components are returned here.</param>
      <returns>X component values. <paramref name="Y" /> and <paramref name="Z" /> are returned as output parameter if requested.</returns>
      <remarks>
        <paramref name="theta" />, <paramref name="radius" /> and <paramref name="Z" /> must be of
            the same size or broadcastable to each other. Output arrays returned are of the same size then the broadcasted
            size of the input arrays.
            <para><paramref name="outZ" /> corresponds to <paramref name="Z" /> but has been broadcasted to the output size.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.poly(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
            //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
            Array<float> y = Optimization.poly(ILMath.array<float>(1.0, 2.1, 1.0, 3.0),ILMath.ones<float>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.poly(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
      <summary>
            Polynomial evaluation
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="c">Vector of coefficients of the polynomial</param>
      <param name="x">Position where the polynomial is to be evaluated. The position may be either a scalar, a vector or a matrix.</param>
      <example>
        <code><![CDATA[
            //Evaluation of the polynomial 1+x+2.1 x + x^2+3x^3 at (1,1,1)
            Array<double> y = ILMath.poly(ILMath.array<double>(1.0, 2.1, 1.0, 3.0), ILMath.ones<double>(3, 1));
            ]]></code>
      </example>
      <returns>The value of a polynomial of degree d at position x, with d=c.lenght-1</returns>
      <remarks> If the input position is an array, the evaluation will be done elementwise<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.pow_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Pow.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prod(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
      <summary>
Computes the product of elements of <paramref name="A" /> along specific dimension <paramref name="dim" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Int64})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Int32})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Int16})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Byte})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.SByte})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Single})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.prodall(ILNumerics.BaseArray{System.Double})">
      <summary>
Computes the product of all elements of <paramref name="A" />.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Scalar array with the product of all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{System.Double})">
      <summary>
            QR decomposition - raw output as returned from LAPACK.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular matrix R
            packed into a single matrix. This is the output of the lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix <paramref name="A" /> is not altered. </para>
        <para>The matrix returned is the direct output of the lapack
            function [d,s,c,z]geqrf, respectively. It contains the decomposition factors Q and R,
            but they are combined into a single matrix. Overloads exist which return Q and R individually:
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean)" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Int32},System.Boolean)">
      <summary>
            QR decomposition with pivoting, potentially size saving shapes.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="R">[Output, optional] Upper triangular matrix. Size [m x n] or [min(m,n) x n] depending
            on <paramref name="economySize" /> (see remarks). Default: (null) do not compute <paramref name="R" />.</param>
      <param name="economySize">[Optional] True: return more efficient structures if possible. See remarks for details. Default: false.</param>
      <param name="E">[Output, optional] Permutation matrix from pivoting. Size [m x m]. Default: (null) do not return.<paramref name="E" />.</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposing <paramref name="A" />. Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> (see remarks).</returns>
      <remarks>
        <para>This function performs the QR decomposition on matrix <paramref name="A" />. It computes matrices Q, <paramref name="R" />
            and <paramref name="E" />, with Q ** R = A ** E, where '**' denotes matrix multiplication.</para>
        <para>If <paramref name="R" /> is null on entry, the function returns the compact QR decomposition result from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double})" />.</para>
        <para>If <paramref name="economySize" /> is false, the function
            returns Q, <paramref name="R" /> and <paramref name="E" /> such that the equation <code>A * E = Q * R</code> holds within
            roundoff errors.</para>
        <para>If <paramref name="economySize" /> is true ... <list type="bullet"><item> and m &gt;= n the size of Q and <paramref name="R" /> will be [m x min(m,n)] and [min(m,n) x n] respectively.
            For m &lt; n the sizes are not changed and as specified above.</item><item>the output parameter <paramref name="E" /> is returned as vector [n] with permutation indices
            rather than as a permutation matrix [n,n]. In this case the equation <code>A[":",E] == Q * R</code> holds, except roundoff errors.</item></list></para>
        <para>
          <paramref name="E" /> reflects the pivoting of <paramref name="A" /> done inside the LAPACK function performing the decomposition so that <paramref name="R" />
            shows increasing diagonal element values. If <paramref name="E" /> is not requested (null) the equation Q ** R = A holds instead.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{System.Single})">
      <summary>
            QR decomposition - raw output as returned from LAPACK.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular matrix R
            packed into a single matrix. This is the output of the lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix <paramref name="A" /> is not altered. </para>
        <para>The matrix returned is the direct output of the lapack
            function [d,s,c,z]geqrf, respectively. It contains the decomposition factors Q and R,
            but they are combined into a single matrix. Overloads exist which return Q and R individually:
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean)" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Int32},System.Boolean)">
      <summary>
            QR decomposition with pivoting, potentially size saving shapes.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="R">[Output, optional] Upper triangular matrix. Size [m x n] or [min(m,n) x n] depending
            on <paramref name="economySize" /> (see remarks). Default: (null) do not compute <paramref name="R" />.</param>
      <param name="economySize">[Optional] True: return more efficient structures if possible. See remarks for details. Default: false.</param>
      <param name="E">[Output, optional] Permutation matrix from pivoting. Size [m x m]. Default: (null) do not return.<paramref name="E" />.</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposing <paramref name="A" />. Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> (see remarks).</returns>
      <remarks>
        <para>This function performs the QR decomposition on matrix <paramref name="A" />. It computes matrices Q, <paramref name="R" />
            and <paramref name="E" />, with Q ** R = A ** E, where '**' denotes matrix multiplication.</para>
        <para>If <paramref name="R" /> is null on entry, the function returns the compact QR decomposition result from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single})" />.</para>
        <para>If <paramref name="economySize" /> is false, the function
            returns Q, <paramref name="R" /> and <paramref name="E" /> such that the equation <code>A * E = Q * R</code> holds within
            roundoff errors.</para>
        <para>If <paramref name="economySize" /> is true ... <list type="bullet"><item> and m &gt;= n the size of Q and <paramref name="R" /> will be [m x min(m,n)] and [min(m,n) x n] respectively.
            For m &lt; n the sizes are not changed and as specified above.</item><item>the output parameter <paramref name="E" /> is returned as vector [n] with permutation indices
            rather than as a permutation matrix [n,n]. In this case the equation <code>A[":",E] == Q * R</code> holds, except roundoff errors.</item></list></para>
        <para>
          <paramref name="E" /> reflects the pivoting of <paramref name="A" /> done inside the LAPACK function performing the decomposition so that <paramref name="R" />
            shows increasing diagonal element values. If <paramref name="E" /> is not requested (null) the equation Q ** R = A holds instead.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            QR decomposition - raw output as returned from LAPACK.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular matrix R
            packed into a single matrix. This is the output of the lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix <paramref name="A" /> is not altered. </para>
        <para>The matrix returned is the direct output of the lapack
            function [d,s,c,z]geqrf, respectively. It contains the decomposition factors Q and R,
            but they are combined into a single matrix. Overloads exist which return Q and R individually:
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean)" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int32},System.Boolean)">
      <summary>
            QR decomposition with pivoting, potentially size saving shapes.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="R">[Output, optional] Upper triangular matrix. Size [m x n] or [min(m,n) x n] depending
            on <paramref name="economySize" /> (see remarks). Default: (null) do not compute <paramref name="R" />.</param>
      <param name="economySize">[Optional] True: return more efficient structures if possible. See remarks for details. Default: false.</param>
      <param name="E">[Output, optional] Permutation matrix from pivoting. Size [m x m]. Default: (null) do not return.<paramref name="E" />.</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposing <paramref name="A" />. Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> (see remarks).</returns>
      <remarks>
        <para>This function performs the QR decomposition on matrix <paramref name="A" />. It computes matrices Q, <paramref name="R" />
            and <paramref name="E" />, with Q ** R = A ** E, where '**' denotes matrix multiplication.</para>
        <para>If <paramref name="R" /> is null on entry, the function returns the compact QR decomposition result from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex})" />.</para>
        <para>If <paramref name="economySize" /> is false, the function
            returns Q, <paramref name="R" /> and <paramref name="E" /> such that the equation <code>A * E = Q * R</code> holds within
            roundoff errors.</para>
        <para>If <paramref name="economySize" /> is true ... <list type="bullet"><item> and m &gt;= n the size of Q and <paramref name="R" /> will be [m x min(m,n)] and [min(m,n) x n] respectively.
            For m &lt; n the sizes are not changed and as specified above.</item><item>the output parameter <paramref name="E" /> is returned as vector [n] with permutation indices
            rather than as a permutation matrix [n,n]. In this case the equation <code>A[":",E] == Q * R</code> holds, except roundoff errors.</item></list></para>
        <para>
          <paramref name="E" /> reflects the pivoting of <paramref name="A" /> done inside the LAPACK function performing the decomposition so that <paramref name="R" />
            shows increasing diagonal element values. If <paramref name="E" /> is not requested (null) the equation Q ** R = A holds instead.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            QR decomposition - raw output as returned from LAPACK.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Orthonormal / unitary matrix Q and upper triangular matrix R
            packed into a single matrix. This is the output of the lapack function ?geqrf.</returns>
      <remarks>
        <para>Input matrix <paramref name="A" /> is not altered. </para>
        <para>The matrix returned is the direct output of the lapack
            function [d,s,c,z]geqrf, respectively. It contains the decomposition factors Q and R,
            but they are combined into a single matrix. Overloads exist which return Q and R individually:
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean)" />.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.qr(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{System.Int32},System.Boolean)">
      <summary>
            QR decomposition with pivoting, potentially size saving shapes.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [m x n].</param>
      <param name="R">[Output, optional] Upper triangular matrix. Size [m x n] or [min(m,n) x n] depending
            on <paramref name="economySize" /> (see remarks). Default: (null) do not compute <paramref name="R" />.</param>
      <param name="economySize">[Optional] True: return more efficient structures if possible. See remarks for details. Default: false.</param>
      <param name="E">[Output, optional] Permutation matrix from pivoting. Size [m x m]. Default: (null) do not return.<paramref name="E" />.</param>
      <returns>Orthonormal / unitary matrix Q as result of decomposing <paramref name="A" />. Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize" /> (see remarks).</returns>
      <remarks>
        <para>This function performs the QR decomposition on matrix <paramref name="A" />. It computes matrices Q, <paramref name="R" />
            and <paramref name="E" />, with Q ** R = A ** E, where '**' denotes matrix multiplication.</para>
        <para>If <paramref name="R" /> is null on entry, the function returns the compact QR decomposition result from <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex})" />.</para>
        <para>If <paramref name="economySize" /> is false, the function
            returns Q, <paramref name="R" /> and <paramref name="E" /> such that the equation <code>A * E = Q * R</code> holds within
            roundoff errors.</para>
        <para>If <paramref name="economySize" /> is true ... <list type="bullet"><item> and m &gt;= n the size of Q and <paramref name="R" /> will be [m x min(m,n)] and [min(m,n) x n] respectively.
            For m &lt; n the sizes are not changed and as specified above.</item><item>the output parameter <paramref name="E" /> is returned as vector [n] with permutation indices
            rather than as a permutation matrix [n,n]. In this case the equation <code>A[":",E] == Q * R</code> holds, except roundoff errors.</item></list></para>
        <para>
          <paramref name="E" /> reflects the pivoting of <paramref name="A" /> done inside the LAPACK function performing the decomposition so that <paramref name="R" />
            shows increasing diagonal element values. If <paramref name="E" /> is not requested (null) the equation Q ** R = A holds instead.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.qr(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.eig(ILNumerics.InArray{System.Single},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)" />
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a symmetric matrix with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Number of columns and number of rows.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Square matrix filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Matrix filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="d5">Length of dimension 5.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="d5">Length of dimension 5.</param>
      <param name="d6">Length of dimension 6.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with random numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Array with target dimension lengths.</param>
      <param name="order">[Optional] Target arrays storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array with random numbers and shape as determined.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rand(System.Int64[])">
      <summary>
            Creates a new array of uniformly distributed, pseudo random values and a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Variable length <see cref="T:System.Array" /> or comma separated list with lengths of the dimensions of the new array.</param>
      <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order, random values.</returns>
      <remarks>
        <para>
          <paramref name="size" /> cannot be <c>null</c>. Its length determines the number of dimensions of the new array. The elements
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
        <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> for
            determining the storage order explicitly.</para>
        <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> instead to provide the dimension lengths.
            This method is recommended when high-performance is important.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <paramref name="size" /> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions" /> or contains negative values.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Creates an array with normally distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Array with target dimension lengths.</param>
      <param name="order">[Optional] Target arrays storage order. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array with random numbers and shape as determined.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64[])">
      <summary>
            Creates a new array of normally distributed, pseudo random values and a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="size">Variable length <see cref="T:System.Array" /> or comma separated list with lengths of the dimensions of the new array.</param>
      <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order, random values.</returns>
      <remarks>
        <para>
          <paramref name="size" /> cannot be <c>null</c>. Its length determines the number of dimensions of the new array. The elements
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
        <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> for
            determining the storage order explicitly.</para>
        <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> instead to provide the dimension lengths.
            This method is recommended when high-performance is important.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <paramref name="size" /> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions" /> or contains negative values.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a square matrix with normally distributed, pseudo random values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Number of columns and rows.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Square matrix filled with random numbers.</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.rand(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.randn(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Matrix filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="d5">Length of dimension 5.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.randn(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates an array with uniformly distributed, pseudo randnom values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Length of dimension 0.</param>
      <param name="d1">Length of dimension 1.</param>
      <param name="d2">Length of dimension 2.</param>
      <param name="d3">Length of dimension 3.</param>
      <param name="d4">Length of dimension 4.</param>
      <param name="d5">Length of dimension 5.</param>
      <param name="d6">Length of dimension 6.</param>
      <param name="order">[Optional] Storage order of elements. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>Array filled with randnom numbers.</returns>
      <remarks>
        <para>Values range from 0.0 to 1.0, uniformly distributed.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.InArray{System.Double},System.Double)">
      <summary>
            Rank of matrix <paramref name="A" />:
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix:</param>
      <param name="tolerance">[Optional] Threshold below which a singular value is considered zero. Default: (-1) auto.</param>
      <returns>Rank of matrix <paramref name="A" />.</returns>
      <remarks>The rank is the number of singular values greater than
            tolerance. If tolerance is smaller than 0 (default), the following default value is used: <code>tol = length(A) * norm(A) * eps</code>,
            with
            <list type="bullet"><item>length(A) - the longest dimension of <paramref name="A" /></item><item>norm(A) - the largest singular value of <paramref name="A" />, see: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Double})" />,</item><item>eps - the distance between 1 and the smallest next greater value.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> has more than 2 dimensions.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.InArray{ILNumerics.fcomplex},System.Single)">
      <summary>
            Rank of matrix <paramref name="A" />:
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix:</param>
      <param name="tolerance">[Optional] Threshold below which a singular value is considered zero. Default: (-1) auto.</param>
      <returns>Rank of matrix <paramref name="A" />.</returns>
      <remarks>The rank is the number of singular values greater than
            tolerance. If tolerance is smaller than 0 (default), the following default value is used: <code>tol = length(A) * norm(A) * epsf</code>,
            with
            <list type="bullet"><item>length(A) - the longest dimension of <paramref name="A" /></item><item>norm(A) - the largest singular value of <paramref name="A" />, see: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.fcomplex})" />,</item><item>epsf - the distance between 1 and the smallest next greater value.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> has more than 2 dimensions.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.InArray{System.Single},System.Single)">
      <summary>
            Rank of matrix <paramref name="A" />:
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix:</param>
      <param name="tolerance">[Optional] Threshold below which a singular value is considered zero. Default: (-1) auto.</param>
      <returns>Rank of matrix <paramref name="A" />.</returns>
      <remarks>The rank is the number of singular values greater than
            tolerance. If tolerance is smaller than 0 (default), the following default value is used: <code>tol = length(A) * norm(A) * epsf</code>,
            with
            <list type="bullet"><item>length(A) - the longest dimension of <paramref name="A" /></item><item>norm(A) - the largest singular value of <paramref name="A" />, see: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{System.Single})" />,</item><item>epsf - the distance between 1 and the smallest next greater value.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> has more than 2 dimensions.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.rank(ILNumerics.InArray{ILNumerics.complex},System.Double)">
      <summary>
            Rank of matrix <paramref name="A" />:
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix:</param>
      <param name="tolerance">[Optional] Threshold below which a singular value is considered zero. Default: (-1) auto.</param>
      <returns>Rank of matrix <paramref name="A" />.</returns>
      <remarks>The rank is the number of singular values greater than
            tolerance. If tolerance is smaller than 0 (default), the following default value is used: <code>tol = length(A) * norm(A) * eps</code>,
            with
            <list type="bullet"><item>length(A) - the longest dimension of <paramref name="A" /></item><item>norm(A) - the largest singular value of <paramref name="A" />, see: <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.svd(ILNumerics.InArray{ILNumerics.complex})" />,</item><item>eps - the distance between 1 and the smallest next greater value.</item></list><para>[ILNumerics Computing Engine]</para></remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="A" /> has more than 2 dimensions.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.real(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Creates array with real parts of complex elements from <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex input array.</param>
      <returns>Array of the same shape and size as <paramref name="A" /> with only the real parts.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Creates array with real parts of complex elements from <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Complex input array.</param>
      <returns>Array of the same shape and size as <paramref name="A" /> with only the real parts.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.InArray{System.Double})">
      <summary>
            Creates a complex array from a real array. This alias for ccomplex(A,0) is now deprecated.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real array A.</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.InArray{System.Single})">
      <summary>
            Creates a complex array from a real array. This alias for ccomplex(A,0) is now deprecated.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Real array A.</param>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rep">Array specifying the repetition factors along each dimension.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New storage with elements of <paramref name="A" /> repeatedly copied as specified by <paramref name="rep" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="rep" /> is null.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="rep" /> are null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="d2">Repetition factor along dimension #2.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="d2">Repetition factor along dimension #2.</param>
      <param name="d3">Repetition factor along dimension #3.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="d2">Repetition factor along dimension #2.</param>
      <param name="d3">Repetition factor along dimension #3.</param>
      <param name="d4">Repetition factor along dimension #4.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="d2">Repetition factor along dimension #2.</param>
      <param name="d3">Repetition factor along dimension #3.</param>
      <param name="d4">Repetition factor along dimension #4.</param>
      <param name="d5">Repetition factor along dimension #5.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.repmat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Replicates <paramref name="A" /> along the given dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="d0">Repetition factor along dimension #0.</param>
      <param name="d1">Repetition factor along dimension #1.</param>
      <param name="d2">Repetition factor along dimension #2.</param>
      <param name="d3">Repetition factor along dimension #3.</param>
      <param name="d4">Repetition factor along dimension #4.</param>
      <param name="d5">Repetition factor along dimension #5.</param>
      <param name="d6">Repetition factor along dimension #6.</param>
      <param name="A">Array to be replicated.</param>
      <returns>New array of the same type as <paramref name="A" /> with elements repeatedly copied as specified by <paramref name="d0" />....</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> is null.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.StorageLayer.BaseStorage`6.Concat(`5,System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            Create reshaped, one dimensional version of <paramref name="A" />. Flattens the array to a vector.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Length of the vector produced. This must be equal to <see cref="P:ILNumerics.Size.NumberOfElements" /> or a negative number.</param>
      <param name="order">[Optional] Storage order for the new array. Default: null (<see cref="P:ILNumerics.Settings.DefaultStorageOrder" />).</param>
      <returns>A new array with the same values as this array, lined up in a 1-dimensional vector.</returns>
      <remarks>
        <para>The (redundant) parameter <paramref name="d0" /> indicates the number of elements along the first
            dimension for the returned array. If <paramref name="d0" /> is positive, its value must equal the number of
            elements in array <paramref name="A" />. If <paramref name="d0" /> is negative, the correct number of elements is substituted automatically.</para>
        <para>The setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" /> is taken into account.
            Therefore - by default - the array returned will have 2 dimensions, since the default value for
            <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" /> is 2.</para>
        <para>The storage order for both: the order for reading
            the elements from this array and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array with a modified size descriptor.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            Create reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim 0.</param>
      <param name="d1">Number of elements along dim 1.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from this array and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified as the values (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim 0.</param>
      <param name="d1">Number of elements along dim 1.</param>
      <param name="d2">Number of elements along dim 2.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim #0.</param>
      <param name="d1">Number of elements along dim #1.</param>
      <param name="d2">Number of elements along dim #2.</param>
      <param name="d3">Number of elements along dim #3.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim #0.</param>
      <param name="d1">Number of elements along dim #1.</param>
      <param name="d2">Number of elements along dim #2.</param>
      <param name="d3">Number of elements along dim #3.</param>
      <param name="d4">Number of elements along dim #4.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim #0.</param>
      <param name="d1">Number of elements along dim #1.</param>
      <param name="d2">Number of elements along dim #2.</param>
      <param name="d3">Number of elements along dim #3.</param>
      <param name="d4">Number of elements along dim #4.</param>
      <param name="d5">Number of elements along dim #5.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="d0">Number of elements along dim #0.</param>
      <param name="d1">Number of elements along dim #1.</param>
      <param name="d2">Number of elements along dim #2.</param>
      <param name="d3">Number of elements along dim #3.</param>
      <param name="d4">Number of elements along dim #4.</param>
      <param name="d5">Number of elements along dim #5.</param>
      <param name="d6">Number of elements along dim #6.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.BaseArray{``0},ILNumerics.InArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})">
      <summary>
            A reshaped version of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="newdims">New dimension lengths.</param>
      <param name="order">[Optional] Storage order for the output array. Default:
            null (Settings.DefaultStorageOrder).</param>
      <returns>Reshaped array.</returns>
      <remarks>
        <para>The storage order for both: the order for reading
            the elements from <paramref name="A" /> and storing the element into the reshaped array is
            determined as follows: </para>
        <list type="bullets">
          <item>If <paramref name="order" /> is specified (<see cref="F:ILNumerics.StorageOrders.ColumnMajor" />
            or <see cref="F:ILNumerics.StorageOrders.RowMajor" />) its value is used for the output. A copy is
            made only if really needed.</item>
          <item>Otherwise, the value of <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> determins the
            target storage order.</item>
        </list>
        <para>A copy of the elements is required for non-continous arrays and - except for
            vector shaped arrays - for unmatching order settings. Otherwise the returned
            array references the same memory as this array and uses another size descriptor only.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <see cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{ILNumerics.StorageOrders})" />
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Round elements to the nearest integer.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Round elements to the nearest integer.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{System.Single})">
      <summary>
Round elements to the nearest integer.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{System.Double})">
      <summary>
Round elements to the nearest integer.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{System.Double},System.Int32)">
      <summary>
Round elements to a specified number of fractional digits.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32)">
      <summary>
Round elements to a specified number of fractional digits.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{ILNumerics.complex},System.Int32)">
      <summary>
Round elements to a specified number of fractional digits.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.round(ILNumerics.BaseArray{System.Single},System.Int32)">
      <summary>
Round elements to a specified number of fractional digits.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
      <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.row``1(``0[])">
      <summary>
            Creates a row vector. This function is deprecated. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])" /> and <see cref="!:reshape&lt;T&gt;(InArray&lt;T&gt;, long, StorageOrders?)" /> instead.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type</typeparam>
      <param name="elements">Elements of the row vector.</param>
      <returns>New row vector.</returns>
      <remarks>
        <para>The same effect is achieved by: <![CDATA[<c>vector<T>(elements).Reshape(1, Equals(elements, null) ? 0 : elements.Length)</c>]]>.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.rshift(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: BitShiftRight.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Signum function of array elements (projection onto unit circle).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Signum function of array elements (projection onto unit circle).
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Byte})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.SByte})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Int16})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Int32})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Int64})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Single})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sign(ILNumerics.BaseArray{System.Double})">
      <summary>
Signum function of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same shape as <paramref name="A" /> with the elementwise result of sign(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.BaseArray{System.Double})">
      <summary>
            Compute the sinus of the elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New array with the same size as <paramref name="A" /> and with the result of the unary operation performed on all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Compute the sinus of the elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New array with the same size as <paramref name="A" /> and with the result of the unary operation performed on all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Compute the sinus of the elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New array with the same size as <paramref name="A" /> and with the result of the unary operation performed on all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sin(ILNumerics.BaseArray{System.Single})">
      <summary>
            Compute the sinus of the elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New array with the same size as <paramref name="A" /> and with the result of the unary operation performed on all elements of <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic sine of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic sine of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Hyperbolic sine of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic sine of A's array elements. See: <see cref="M:ILNumerics.complex.Cosh(ILNumerics.complex)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.BaseArray{System.Single})">
      <summary>
Hyperbolic sine of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic sine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sinh(ILNumerics.BaseArray{System.Double})">
      <summary>
Hyperbolic sine of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic sine of A's array elements. See: <see cref="M:System.Math.Cosh(System.Double)" /></returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size">
      <summary>
            Provides empty dimension lengths for operations expecting a size argument.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <c><![CDATA[empty<long>(0)]]></c> and returns a vector
            of 0 <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 1 dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 2 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 3 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 4 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 5 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 6 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets 7 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0)" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.size(System.Int64[])">
      <summary>
            Provides dimension lengths for operations expecting a size argument. Targets more than 7 dimensions.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>This function is an alias for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])" /> and returns a vector
            of <see cref="T:System.Int64" /> elements.</para>
        <para>For situations requiring high-performance execution you may consider using <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0[])" />
            in order to create the required size vector once. Keep this size array around and reuse it.
            This prevents one from allocating additional, GC managed memory from the managed heap and may helps
            to increase the performance / to decrease GC activity. Otherwise, the 'params' (variable length argument)
            may puts pressure on the GC when used frequently in tight loops.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.InArray{System.String})">
      <summary>
            Sort strings in A along first non singleton dimension, ascending order.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data
            along the first non singleton dimension will get sorted independently from data
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.InArray{System.String},System.Boolean)">
      <summary>
            Sort strings in A along first non singleton dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data
            along the first non singleton dimension will get sorted independently from data
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.InArray{System.String},System.Int32,System.Boolean)">
      <summary>
            Sort strings in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
      <param name="dim">Dimension to sort along</param>
      <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
      <returns>Sorted array of the same size/shape as A</returns>
      <remarks>
        <para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data
            along the first non singleton dimension will get sorted independently from data
            in the other rows/columns.</para>
        <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.InArray{System.String},ILNumerics.OutArray{System.Double},System.Int32,System.Boolean)">
      <summary>
            Sort data in A along dimension 'dim'
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Output] Returns permutation matrix also</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the bucket sort algorithm. Data
            along the dimension <paramref name="dim" /> will get sorted independently from data
            in the next row/column.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort``3(ILNumerics.InArray{``0},ILNumerics.OutArray{``2},System.Int32,System.Boolean,ILNumerics.Core.Misc.KeyMapper{``0,``1})">
      <summary>
            Generic bucket sort algorithm in A along arbitrary dimension
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array: empty, scalar, vector or matrix</param>
      <param name="descending">Specifies the direction of sorting</param>
      <param name="dim">Dimension to sort along</param>
      <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements
            in A. This can be used to derive a permutation matrix of the sorted indices.</param>
      <typeparam name="T">Element type of values of A</typeparam>
      <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
      <typeparam name="I">Element type of indices</typeparam>
      <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must
            be derived from ILKeyMapper{T,SubelementType} and match the generic argument <typeparamref name="T" />. It will be
            used to split single elements into its subelements and map their content into bucket numbers. For all
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
      <returns>Sorted array of the same size as A</returns>
      <remarks>
        <para>The data in A will be sorted using the bucket sort algorithm. Data
            along the dimension <paramref name="dim" /> will get sorted independently. I.e., for dim = 0, columns are sorted independently.</para>
        <para>This overload also returns an array 'Indices' which will hold the indices into the original
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
        <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
        <para>By using this overload you may use the same permutation matrix several times to reflect the
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting
            disregarding initial order.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension. Computes indices also.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="Indices">[Output] On return contains the indices required to sort the array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>If <paramref name="Indices" /> is of the same shape as (non-empty, non-scalar) <paramref name="A" /> on entry, its content is sorted with
            the values of A. Otherwise and if <paramref name="Indices" /> is null or not of the same shape as <paramref name="A" />
            the function will resize <paramref name="Indices" /> and fill it with zero based indices along the working dimension and sort
            these together with <paramref name="A" />.</para>
        <para>It is recommended to initialize <paramref name="Indices" /> with 0 or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> to indicate
            that the indices are required. If <paramref name="A" /> is scalar and <paramref name="Indices" /> is not null, any predefined value of <paramref name="Indices" />
            is ignored and 0 is returned in <paramref name="Indices" />. That means that initializing <paramref name="Indices" /> with 1
            or any other scalar literal (for ease of use) does work also, as long as <paramref name="A" /> is not scalar.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
            Sort elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="descending">[Optional] Determins the sorting direction. Default: (false) ascending.</param>
      <param name="dim">The index of the working dimension or -1 for determining the working dimension automatically (default).</param>
      <returns>New array with the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The working dimension for <paramref name="dim" /> = -1 depends on the value of <see cref="P:ILNumerics.Settings.ArrayStyle" />.
            For numpy style it starts with the last dimension to search for a non-singleton dimension. For ILNumericsV4 the search starts
            with the first dimension (index #0).</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sphere2cart(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Transforms spherical coordinates into cartesian coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="radius">Radial distance.</param>
      <param name="theta">Polar angle.</param>
      <param name="phi">Azimuthal angle.</param>
      <param name="Y">[Optional] Output: Y coordinates. Default: (null) do not compute.</param>
      <param name="Z">[Optional] Output: Z coordinates. Default: (null) do not compute.</param>
      <returns>X coordinates.<paramref name="Y" /> and <paramref name="Z" /> are returned on request.</returns>
      <remarks> The input parameters <paramref name="radius" />, <paramref name="theta" /> and <paramref name="phi" />
            must be of the same size or be broadcastable to each other. All arrays returned are of the broadcasted size.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sphere2cart(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Transforms spherical coordinates into cartesian coordinates.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="radius">Radial distance.</param>
      <param name="theta">Polar angle.</param>
      <param name="phi">Azimuthal angle.</param>
      <param name="Y">[Optional] Output: Y coordinates. Default: (null) do not compute.</param>
      <param name="Z">[Optional] Output: Z coordinates. Default: (null) do not compute.</param>
      <returns>X coordinates.<paramref name="Y" /> and <paramref name="Z" /> are returned on request.</returns>
      <remarks> The input parameters <paramref name="radius" />, <paramref name="theta" /> and <paramref name="phi" />
            must be of the same size or be broadcastable to each other. All arrays returned are of the broadcasted size.<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Square root of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrt(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Square root of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrt(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.BaseArray{System.Single})">
      <summary>
Square root of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrt(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.BaseArray{System.Double})">
      <summary>
Square root of array elements - real output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrt(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.BaseArray{System.Single})">
      <summary>
Square root of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrtc(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.BaseArray{System.Double})">
      <summary>
Square root of array elements - complex output.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" /> with elementwise result of sqrtc(A)..</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.squeeze``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Creates an array similar to this array, having singleton dimensions removed.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array, will not be altered.</param>
      <returns>New array without singleton dimension.</returns>
      <remarks>This function (as all functions in ILNumerics) respects the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />.
            Thus, commonly, the array returned may still has up to two singleton dimensions, if <see cref="P:ILNumerics.Settings.ArrayStyle" /> is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />.
            <para>Note that removing singleton dimensions does not change the number of elements of the array. Hence, no copy is made
            for <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.squeeze``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="!:reshape&lt;T&gt;(InArray&lt;T&gt;, long, long, long, long, StorageOrders?)" />
    </member>
    <member name="M:ILNumerics.ILMath.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
      <summary>
            Computes sequential (linear) indices from dimensional indices.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The input array providing the size, strides and element type to compute the sequential indices for.</param>
      <param name="indices">Dimensional index tuples into <paramref name="A" /> as m elements of n rows. Matrix [m, n].</param>
      <returns>Vector [m] with sequential element indices into <paramref name="A" /> according to the subscript indices (rows) from <paramref name="indices" />.</returns>
      <remarks>
        <para>This function converts subscript indices into sequential element indices. Subscript indices specify the position of an
            element in <paramref name="A" /> by giving the position of the element in each dimension individually. Hence, n subscript indices are
            required to describe a single element position in <paramref name="A" />. In contrast to that, sequential indices specify the position of an
            element in <paramref name="A" /> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index
            is than simply the index of the element in the line.</para>
        <para>The (virtual) lining-up of the elements in <paramref name="A" /> is performed in <i>column major order</i>. Note,
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            and by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            is not related to the actual order of the elements as they are stored in memory.</para>
        <para>If <paramref name="indices" /> has fewer columns as dimensions exist in <paramref name="A" /> indices into unspecified dimensions
            are considered 0. The last column of <paramref name="indices" /> may contains values as indices into the <i>merged trailing</i>
            dimensions of <paramref name="A" />.</para>
        <para>The vector returned gives the sequential index for each element specified as a row in <paramref name="indices" />. A sequential index
            corresponds to the 0-based index of the element after lining-up all elements of <paramref name="A" />, starting at element 0 and walking
            along the array in column major order.</para>
        <para>
          <paramref name="indices" /> can contain values addressing non-existing elements in <paramref name="A" /> (indices out-of-range).
            These indices will produce invalid sequential indices and do not produce an error. Also, no error is generated for negative values
            in <paramref name="indices" />! The special meaning of latter (i.e.: counting from the end) is not considered here.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives
            the original data.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> has less than 1 dimension.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="indices" /> are null.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.UInt32})">
      <summary>
            Computes sequential (linear) indices from dimensional indices.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The input array providing the size, strides and element type to compute the sequential indices for.</param>
      <param name="indices">Dimensional index tuples into <paramref name="A" /> as m elements of n rows. Matrix [m, n].</param>
      <returns>Vector [m] with sequential element indices into <paramref name="A" /> according to the subscript indices (rows) from <paramref name="indices" />.</returns>
      <remarks>
        <para>This function converts subscript indices into sequential element indices. Subscript indices specify the position of an
            element in <paramref name="A" /> by giving the position of the element in each dimension individually. Hence, n subscript indices are
            required to describe a single element position in <paramref name="A" />. In contrast to that, sequential indices specify the position of an
            element in <paramref name="A" /> by a single sequential index, where all elements are considered to be 'lined-up'. The sequential index
            is than simply the index of the element in the line.</para>
        <para>The (virtual) lining-up of the elements in <paramref name="A" /> is performed in <i>column major order</i>. Note,
            that the order considered by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            and by <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            is not related to the actual order of the elements as they are stored in memory.</para>
        <para>If <paramref name="indices" /> has fewer columns as dimensions exist in <paramref name="A" /> indices into unspecified dimensions
            are considered 0. The last column of <paramref name="indices" /> may contains values as indices into the <i>merged trailing</i>
            dimensions of <paramref name="A" />.</para>
        <para>The vector returned gives the sequential index for each element specified as a row in <paramref name="indices" />. A sequential index
            corresponds to the 0-based index of the element after lining-up all elements of <paramref name="A" />, starting at element 0 and walking
            along the array in column major order.</para>
        <para>
          <paramref name="indices" /> can contain values addressing non-existing elements in <paramref name="A" /> (indices out-of-range).
            These indices will produce invalid sequential indices and do not produce an error. Also, no error is generated for negative values
            in <paramref name="indices" />! The special meaning of latter (i.e.: counting from the end) is not considered here.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sub2ind``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})" />
            and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ind2sub``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64},System.Int32)" />
            are equivalent operations, inverting the results of the respective other function. Combining both functions creates a roundtrip and gives
            the original data.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">if <paramref name="A" /> has less than 1 dimension.</exception>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="indices" /> are null.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.subtract_sat(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Binary, elementwise, broadcasting operation: Subtract.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The one array.</param>
      <param name="B">The other array.</param>
      <returns>Result of operating elements of <paramref name="A" /> and <paramref name="B" /> elementwise.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sum(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)">
      <summary>
            Compute the sum of elements of <paramref name="A" /> along the specified dimension.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
      <param name="dim">[Optional] The index of the dimension to be reduced. Default: (-1) the first non-singleton dimension found in <paramref name="A" /> or 0.</param>
      <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
      <remarks>
        <para></para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Double})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Int64})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Int32})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Int16})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Byte})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.SByte})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.sumall(ILNumerics.BaseArray{System.Single})">
      <summary>
            Computes the sum of all elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input array.</param>
      <returns>New scalar array with the sum of all elements.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>This operation returns a scalar array, regardless of the shape of <paramref name="A" />. The number of dimensions
            of the scalar returned depends on the setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions" />. If <paramref name="A" />
            is empty the scalar value returned corresponds to the default value of the element datatype. For numerical element types the
            default value is 0. For boolean / logical elements the default is false.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Double})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Vector with min(M,N) singular values of <paramref name="A" />, where A.S is [M,N].</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [M,N]</param>
      <param name="U">[Output, Optional] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Optional, output] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <param name="small">If true: return only first min(M,N) singular values. Reduces <paramref name="outU" /> to size [min(M,N),min(M,N)]. Default: false.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Output] Returns left singular vectors of <paramref name="A" /> as columns. Must be non-null on entry.</param>
      <param name="outV">[Output] Returns right singular vectors of <paramref name="A" /> as rows of matrix V. Must be non-null on entry and will be replaced with new values on return.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double},System.Boolean,System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="outU">[Output] Left singular vectors of <paramref name="A" /> as columns. Provide null if this information is not required.</param>
      <param name="outV">[Output] Right singular vectors of <paramref name="A" /> as rows. Must be non-null on entry and will be replaced with new values on return.</param>
      <param name="small">If true: return only the first min(M,N) singlular values. Decreases the size of the array returned to [min(M,N),min(M,N)].</param>
      <param name="discardFiniteTest">true: the matrix given will not be checked for infinte or NaN values. If such elements
            exist, convergence failure or an error might occur. Use with care! </param>
      <returns>Singluar values as real diagonal matrix of same size and precicion as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Single})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Vector with min(M,N) singular values of <paramref name="A" />, where A.S is [M,N].</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [M,N]</param>
      <param name="U">[Output, Optional] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Optional, output] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <param name="small">If true: return only first min(M,N) singular values. Reduces <paramref name="outU" /> to size [min(M,N),min(M,N)]. Default: false.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Output] Returns left singular vectors of <paramref name="A" /> as columns. Must be non-null on entry.</param>
      <param name="outV">[Output] Returns right singular vectors of <paramref name="A" /> as rows of matrix V. Must be non-null on entry and will be replaced with new values on return.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single},System.Boolean,System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="outU">[Output] Left singular vectors of <paramref name="A" /> as columns. Provide null if this information is not required.</param>
      <param name="outV">[Output] Right singular vectors of <paramref name="A" /> as rows. Must be non-null on entry and will be replaced with new values on return.</param>
      <param name="small">If true: return only the first min(M,N) singlular values. Decreases the size of the array returned to [min(M,N),min(M,N)].</param>
      <param name="discardFiniteTest">true: the matrix given will not be checked for infinte or NaN values. If such elements
            exist, convergence failure or an error might occur. Use with care! </param>
      <returns>Singluar values as real diagonal matrix of same size and precicion as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Vector with min(M,N) singular values of <paramref name="A" />, where A.S is [M,N].</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [M,N]</param>
      <param name="U">[Output, Optional] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Optional, output] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <param name="small">If true: return only first min(M,N) singular values. Reduces <paramref name="outU" /> to size [min(M,N),min(M,N)]. Default: false.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Output] Returns left singular vectors of <paramref name="A" /> as columns. Must be non-null on entry.</param>
      <param name="outV">[Output] Returns right singular vectors of <paramref name="A" /> as rows of matrix V. Must be non-null on entry and will be replaced with new values on return.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},System.Boolean,System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="outU">[Output] Left singular vectors of <paramref name="A" /> as columns. Provide null if this information is not required.</param>
      <param name="outV">[Output] Right singular vectors of <paramref name="A" /> as rows. Must be non-null on entry and will be replaced with new values on return.</param>
      <param name="small">If true: return only the first min(M,N) singlular values. Decreases the size of the array returned to [min(M,N),min(M,N)].</param>
      <param name="discardFiniteTest">true: the matrix given will not be checked for infinte or NaN values. If such elements
            exist, convergence failure or an error might occur. Use with care! </param>
      <returns>Singluar values as real diagonal matrix of same size and precicion as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <returns>Vector with min(M,N) singular values of <paramref name="A" />, where A.S is [M,N].</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [M,N]</param>
      <param name="U">[Output, Optional] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Optional, output] Returns left singular vectors of <paramref name="A" /> as columns. Default: (null) do not compute.</param>
      <param name="small">If true: return only first min(M,N) singular values. Reduces <paramref name="outU" /> to size [min(M,N),min(M,N)]. Default: false.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix. Size [M,N].</param>
      <param name="outU">[Output] Returns left singular vectors of <paramref name="A" /> as columns. Must be non-null on entry.</param>
      <param name="outV">[Output] Returns right singular vectors of <paramref name="A" /> as rows of matrix V. Must be non-null on entry and will be replaced with new values on return.</param>
      <returns>Singluar values as real diagonal matrix of same size and precision as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.svd(ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},System.Boolean,System.Boolean)">
      <summary>
            Singular value decomposition.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix.</param>
      <param name="outU">[Output] Left singular vectors of <paramref name="A" /> as columns. Provide null if this information is not required.</param>
      <param name="outV">[Output] Right singular vectors of <paramref name="A" /> as rows. Must be non-null on entry and will be replaced with new values on return.</param>
      <param name="small">If true: return only the first min(M,N) singlular values. Decreases the size of the array returned to [min(M,N),min(M,N)].</param>
      <param name="discardFiniteTest">true: the matrix given will not be checked for infinte or NaN values. If such elements
            exist, convergence failure or an error might occur. Use with care! </param>
      <returns>Singluar values as real diagonal matrix of same size and precicion as <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the tangents of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the tangents of A's array elements. See: <see cref="M:ILNumerics.complex.Tan(ILNumerics.complex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.BaseArray{System.Single})">
      <summary>
Tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the tangents of A's array elements. See: <see cref="M:System.Math.Tan(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tan(ILNumerics.BaseArray{System.Double})">
      <summary>
Tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the tangents of A's array elements. See: <see cref="M:System.Math.Tan(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Hyperbolic tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic tangents of A's array elements. See: <see cref="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Hyperbolic tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic tangents of A's array elements. See: <see cref="M:ILNumerics.complex.Tanh(ILNumerics.complex)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.BaseArray{System.Single})">
      <summary>
Hyperbolic tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic tangents of A's array elements. See: <see cref="M:System.Math.Tanh(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tanh(ILNumerics.BaseArray{System.Double})">
      <summary>
Hyperbolic tangent of array elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array of the same size/type as <paramref name="A" /> with the hyperbolic tangents of A's array elements. See: <see cref="M:System.Math.Tanh(System.Double)" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Complex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{complex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Byte" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Double" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.todouble(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Double.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{double} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:ILNumerics.fcomplex" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to FComplex.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{fcomplex} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Int16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int16" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint16(ILNumerics.BaseArray{System.UInt16})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Int32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{int} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int32" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint32(ILNumerics.BaseArray{System.UInt32})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Int64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{long} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Int64" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint64(ILNumerics.BaseArray{System.UInt64})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to SByte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{sbyte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.SByte" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.toint8(ILNumerics.BaseArray{System.Byte})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tological(ILNumerics.BaseArray)">
      <summary>
            Creates a logical array with 'true' values at the positions with non-0 elements of <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Single.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{float} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Single" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to UInt16.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ushort} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt16" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint16(ILNumerics.BaseArray{System.Int16})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt32" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Int32})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint32(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to UInt32.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{uint} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Byte})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.SByte})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to UInt64.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{ulong} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.UInt64" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint64(ILNumerics.BaseArray{System.Int64})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.UInt16})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Int16})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.UInt32})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Int32})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.UInt64})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Int64})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Single})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Double})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{byte} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed on all elements of the input array <paramref name="A" />.</para>
        <para>The storage order of the array returned depends on the order of <paramref name="A" />. If
            <paramref name="A" />.<see cref="P:ILNumerics.Size.IsContinuous" /> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />. Otherwise, the elements of the returned array will be reordered in the order defined by
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder" /> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />).</para>
        <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads" />.</para>
        <para>The input array <paramref name="A" /> is not altered. However, if <paramref name="A" />'s storage is suitable and not
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray)">
      <summary>
            Convert numeric array of unknown type to an ILNumerics array with <see cref="T:System.Byte" /> elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Source array.</param>
      <returns>New array.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.SByte})">
      <summary>
(Reinterpret) cast array of unsigned elements to signed elements.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Array{short} of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying any elements. The returned array
            has the same storage order and the same size as A.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.touint8(ILNumerics.BaseArray{System.Boolean})">
      <summary>
Convert elements to Byte.
<para>[ILNumerics Computing Engine]</para>
</summary>
      <param name="A">Input array.</param>
      <returns>Logical of the same shape as <paramref name="A" />.</returns>
      <remarks>
        <para>The operation is efficiently performed without copying elements of <paramref name="A" />.</para>
        <para>The array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder" />
            as <paramref name="A" />.</para>
        <para>The operation is performed by 'reinterprete-cast'-ing <paramref name="A" /> to the new output type.</para>
        <para>The input array <paramref name="A" /> is not altered.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Double})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Byte})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.SByte})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.UInt16})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Int16})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.UInt32})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Int32})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.UInt64})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Int64})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{ILNumerics.fcomplex})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{System.Single})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.trace(ILNumerics.InArray{ILNumerics.complex})">
      <summary>
            Trace of matrix.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Scalar of same type as <paramref name="A" /> with the sum of diagonal elements of <paramref name="A" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.tril``1(ILNumerics.InArray{``0})">
      <summary>
            Extract lower triangular part of matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Array of size [m x n], holding lower triangular part of <paramref name="A" />.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="A" /> has more than 2 dimensions.</exception>
      <remarks>
        <para>The diagonal elements of <paramref name="A" /> are not included in the lower triangular matrix returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.triu``1(ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.triu``1(ILNumerics.InArray{``0})">
      <summary>
            Extract upper triangular part of matrix <paramref name="A" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="A">Input matrix, size [m x n].</param>
      <returns>Array of size [m x n], holding upper triangular part of <paramref name="A" />.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="A" /> has more than 2 dimensions.</exception>
      <remarks>
        <para>The diagonal elements of <paramref name="A" /> are included in the upper triangular matrix returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.tril``1(ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.vec(System.Double,System.Double)">
      <summary>
            Creates vector of evenly spaced values over a closed interval, elements of <see cref="T:System.Double" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <returns>Vector with n equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" /> instead!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.vec(System.Double,System.Double,System.Double)">
      <summary>
            Creates vector of evenly spaced values of certain step size over a closed interval, elements of <see cref="T:System.Double" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <param name="step">Step value.</param>
      <returns>Vector with equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double,System.Double)" /> and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec(System.Double,System.Double)" /> can not create
            empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />,
            <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or
            the similar to create empty arrays.</para>
        <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" /> instead!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.vec``1(``0,``0)">
      <summary>
            Creates vector of evenly spaced values over a closed interval, elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value, inclusive.</param>
      <param name="end">End value, inclusive.</param>
      <returns>Vector with n equally spaced elements from <paramref name="start" /> to <paramref name="end" />, all with interval 1.</returns>
      <remarks>
        <para>The last element of the returned vector is less than or equal to <paramref name="end" />.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" /> instead!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if <paramref name="start" /><![CDATA[>]]><paramref name="end" />,
            if <typeparamref name="T" /> is not a supported numeric value type, if <paramref name="start" /> or <paramref name="end" /> is
            not scalar, is null or is not of a supported numeric, convertible element type.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.vec``1(``0,``0,``0)">
      <summary>
            Creates vector of N evenly spaced values of given step size over a closed interval, numeric, real elements of type <typeparamref name="T" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="start">Start value.</param>
      <param name="step">Step size.</param>
      <param name="end">End value.</param>
      <returns>(Column) vector of length N.</returns>
      <remarks>
        <para>The function creates N values from <paramref name="start" /> to <paramref name="end" />, all equally spaced with stepsize <paramref name="step" />.<paramref name="step" />.</para>
        <para>The last element of the returned vector will be less than or equal to <paramref name="end" />, if <paramref name="start" /><![CDATA[<]]><paramref name="end" />. </para>
        <para>If <paramref name="start" /><![CDATA[>]]><paramref name="end" /> elements in the vector will linearly <i>decrease</i> from
            <paramref name="start" /> to <paramref name="end" />. In this case, <paramref name="step" /> must be negative.</para>
        <para>Values are computed in the precision of the datatype <typeparamref name="T" />. For integer <typeparamref name="T" /> this may imply rounding issues.</para>
        <para>
          <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vec``1(``0,``0,``0)" /> can not create empty vectors! Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" /> or the like to create empty arrays.</para>
        <para>This function is provided for compatibility with older versions only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" /> instead!</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentException"> if either of <paramref name="start" />, <paramref name="end" />, or
            <paramref name="step" /> is null, non-numeric, or non-scalar, if <paramref name="step" /> is 0 or the sign
            of <paramref name="step" /> does not match the sign of 'end - start'.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.counter``1(``0,``0,System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.arange``2(``0,``1,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.linspace``1(ILNumerics.InArray{``0},ILNumerics.InArray{``0},ILNumerics.InArray{``0})" />
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(System.Int64,System.Func{System.Int64,``0})">
      <summary>
            Generator function, creates vector of specified length, compute values by index.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="length">The number of elements for the new vector.</param>
      <param name="func">Generator function, transforms the 0-based index into a value.</param>
      <returns>Vector of given <paramref name="length" /> with values computed based on their index.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0[])">
      <summary>
            Creates a vector from provided 1-D <see cref="T:System.Array" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="values">.Net array with values for the new vector.</param>
      <returns>New ILNumerics array with number and values of elements as given by <paramref name="values" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0)">
      <summary>
            Creates a new scalar ILNumerics 1-D array with the given value.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">The single value for the target array.</param>
      <returns>ILNumerics scalar of type <typeparamref name="T" />.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">First value.</param>
      <param name="v1">Second value.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">First value.</param>
      <param name="v1">Second value.</param>
      <param name="v2">Third value.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <param name="v15">Value #15.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <param name="v15">Value #15.</param>
      <param name="v16">Value #16.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <param name="v15">Value #15.</param>
      <param name="v16">Value #16.</param>
      <param name="v17">Value #17.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <param name="v15">Value #15.</param>
      <param name="v16">Value #16.</param>
      <param name="v17">Value #17.</param>
      <param name="v18">Value #18.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)">
      <summary>
            Initializes a new ILNumerics vector with given values.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="v0">Value #0.</param>
      <param name="v1">Value #1.</param>
      <param name="v2">Value #2.</param>
      <param name="v3">Value #3.</param>
      <param name="v4">Value #4.</param>
      <param name="v5">Value #5.</param>
      <param name="v6">Value #6.</param>
      <param name="v7">Value #7.</param>
      <param name="v8">Value #8.</param>
      <param name="v9">Value #9.</param>
      <param name="v10">Value #10.</param>
      <param name="v11">Value #11.</param>
      <param name="v12">Value #12.</param>
      <param name="v13">Value #13.</param>
      <param name="v14">Value #14.</param>
      <param name="v15">Value #15.</param>
      <param name="v16">Value #16.</param>
      <param name="v17">Value #17.</param>
      <param name="v18">Value #18.</param>
      <param name="v19">Value #19.</param>
      <returns>ILNumerics vector with given values.</returns>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the columns of <paramref name="A" /> extended by the columns of <paramref name="B" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>The size of both arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" /> or <paramref name="B" /> are null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" /> and <paramref name="B" /> do not match.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:ILNumerics.ILMath.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the columns of <paramref name="A" /> extended by the columns of <paramref name="B" /> and <paramref name="C" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <param name="C">The third array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" /> and <paramref name="C" />.</returns>
      <remarks>
        <para>The size of all arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> are null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" />, <paramref name="B" /> and/or <paramref name="C" /> do not match.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:ILNumerics.ILMath.vertcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
      <summary>
            Create new array with the columns of <paramref name="A" /> extended by the columns of <paramref name="B" /> and <paramref name="C" /> and <paramref name="D" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <param name="C">The third array.</param>
      <param name="D">The fourth array.</param>
      <returns>New array with elements of <paramref name="A" /> and <paramref name="B" /> and <paramref name="C" />.</returns>
      <remarks>
        <para>The size of all arrays must match. This means that all but the first dimension (#0) must have the same lengths.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="A" />, <paramref name="B" /> or <paramref name="C" /> are null.</exception>
      <exception cref="T:System.ArgumentException"> if the sizes of <paramref name="A" />, <paramref name="B" /> and/or <paramref name="C" /> do not match.</exception>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.concat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.horzcat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Double},ILNumerics.BaseArray{System.Double})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Double" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Boolean},ILNumerics.BaseArray{System.Boolean})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.UInt64},ILNumerics.BaseArray{System.UInt64})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Int64},ILNumerics.BaseArray{System.Int64})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int64" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.UInt32},ILNumerics.BaseArray{System.UInt32})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Int32},ILNumerics.BaseArray{System.Int32})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int32" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.UInt16},ILNumerics.BaseArray{System.UInt16})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.UInt16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Int16},ILNumerics.BaseArray{System.Int16})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Int16" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Byte},ILNumerics.BaseArray{System.Byte})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Byte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.SByte},ILNumerics.BaseArray{System.SByte})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.SByte" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.BaseArray{ILNumerics.fcomplex})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.fcomplex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.BaseArray{ILNumerics.complex})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:ILNumerics.complex" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.xor(ILNumerics.BaseArray{System.Single},ILNumerics.BaseArray{System.Single})">
      <summary>
            Elementwise 'Xor' comparison operator on two arrays.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="A">The first array.</param>
      <param name="B">The second array.</param>
      <returns>Logical array with the size broadcasted from <paramref name="A" /> and <paramref name="B" />.</returns>
      <remarks>
        <para>General notes on binary broadcasting operators: The operation is performed
            elementwise on corresponding elements of <paramref name="A" /> and <paramref name="B" />. The sizes of both
            input arrays must be broadcastable and determine the size of the resulting array. Note, that
            broadcasting is performed, regardless of the current setting of <see cref="P:ILNumerics.Settings.ArrayStyle" />. However,
            the <see cref="P:ILNumerics.Settings.ArrayStyle" /> configuration affects the operation in the following ways:
            <list type="bullet"><item>If <paramref name="A" /> and <paramref name="B" /> have different number of dimensions, the array with
            fewer dimensions is (virtually) padded with singleton dimensions, until the number of dimensions of both arrays match. In
            <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" /> the singleton dimensions are added to the end of dimensions. For <see cref="F:ILNumerics.ArrayStyles.numpy" />
            singletons are padded to the start, such that here, broadcasting aligns the <i>last</i> dimensions.</item><item><see cref="F:ILNumerics.ArrayStyles.ILNumericsV4" />: Result values of integer element types T are clamped to the
            natural range of the interger type. I.e.: there will be no 'wrapping around' when exceeding the upper or lower
            limits of the natural value range of the integer type. Also, the operation may be performed by utilizing <see cref="T:System.Single" /> precision
            floating point arithmetics and subsequently casting the result to the desired integer value. For <see cref="F:ILNumerics.ArrayStyles.numpy" /> no such
            precautions exist and the result of the binary operation is exactly the same as for operating the elements as System types (and as in numpy itself).</item></list></para>
        <para>This function is parallelized for multiple cores. If possible, a suitable <paramref name="A" /> or <paramref name="B" /> is
            directly utilized in order to perform the operation inplace: instead of storing the results into new memory the
            input array and/or its storage is reused and returned.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso href="https://ilnumerics.net/array-operators_v5.html" />
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64)">
      <summary>
            Creates a square matrix of 0.0-valued <see cref="T:System.Double" /> elements, size [dim0, dim0].
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="rows_columns">Length of dimension #0 and dimension #1.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <remarks>This creates a square matrix with the same number of rows and columns. The elements
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> order.
            <para>This function always creates a matrix, hence the array returned will always have
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle" /> allows it.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64)">
      <summary>
            Creates a matrix of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new ILNumerics array of 0.0-valued <see cref="T:System.Double" /> elements. Storage order: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a square matrix of 0-valued elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="rows_columns">Length of dimension #0 and dimension #1 (the number of rows and columns).</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <remarks>This creates a square matrix with the same number of rows and columns. The elements
            are ordered in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> order.
            <para>This function always creates a matrix, hence the array returned will always have
            two dimensions. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0)" /> or <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
            for creating arrays with less than two dimension if your setting of <see cref="P:ILNumerics.Settings.ArrayStyle" /> allows it.</para><para>[ILNumerics Computing Engine]</para></remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,ILNumerics.StorageOrders)">
      <summary>
            Creates a new ILNumerics array of 0 elements.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type.</typeparam>
      <param name="dim0">Length of dimension #0.</param>
      <param name="dim1">Length of dimension #1.</param>
      <param name="dim2">Length of dimension #2.</param>
      <param name="dim3">Length of dimension #3.</param>
      <param name="dim4">Length of dimension #4.</param>
      <param name="dim5">Length of dimension #5.</param>
      <param name="dim6">Length of dimension #6.</param>
      <param name="order">[Optional] The storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New ILNumerics array initialized with default(T).</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(ILNumerics.Size,ILNumerics.StorageOrders)">
      <summary>
            Create a new array of zeros '0' with the same size as <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="size">Number and lengths of the dimensions for the new array.</param>
      <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array of the specified size and storage order, initialized with '0'.</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)">
      <summary>
            Create a new array of zeros '0' with dimensions number and lengths as determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array.</typeparam>
      <param name="size">Number and lengths of the dimensions for the new array.</param>
      <param name="order">[Optional] Storage order for the new array. Default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor" />.</param>
      <returns>New array of the specified size and storage order, initialized with '0'.</returns>
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.zeros``1(System.Int64[])">
      <summary>
            Creates a new array of zeros '0' with a size determined by <paramref name="size" />.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <typeparam name="T">Element type for the new array. This must be a value type.</typeparam>
      <param name="size">Variable length <see cref="T:System.Array" /> or comma separated list with lengths of the dimensions of the new array.</param>
      <returns>New array of the specified size and <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order, initialized with '0'.</returns>
      <remarks>
        <para>
          <paramref name="size" /> cannot be <c>null</c>. Its lengths determines the number of dimensions of the new array. The elements
            determine the lengths of corresponding dimensions and cannot contain negative values.</para>
        <para>Arrays returned from this overload are in <see cref="F:ILNumerics.StorageOrders.ColumnMajor" /> storage order. Use <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> for
            determining the storage order explicitly.</para>
        <para>Since the variable length parameter list and the 'params' keyword (C#) implicitly allocates new storage under the control of the
            GC consider using one of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0)" /> overloads and <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" /> instead to provide the dimension lengths.
            This is recommended when high-performance is important.</para>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.zeros``1(ILNumerics.InArray{System.Int64},ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.array``1(``0,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.vector``1(``0,``0,``0,``0,``0,``0,``0,``0,``0,``0)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.ones``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.empty``1(System.Int64,System.Int64,ILNumerics.StorageOrders)" />
      <seealso cref="F:ILNumerics.Size.MaxNumberOfDimensions" />
      <seealso href="https://ilnumerics.net/ArrayCreation3.html" />
      <exception cref="T:System.ArgumentException">if <typeparamref name="T" /> is not supported. Use one of the predefined, scalar value types (<see cref="T:System.Double" />, float, int, ...),
            <see cref="T:ILNumerics.complex" /> or <see cref="T:ILNumerics.fcomplex" />.</exception>
      <exception cref="T:System.ArgumentException">if <paramref name="size" /> is null, has more elements than <see cref="F:ILNumerics.Size.MaxNumberOfDimensions" /> or contains negative values.</exception>
    </member>
    <member name="P:ILNumerics.ILMath.Lapack">
      <summary>
            This member provides the currently selected LAPACK implementation for linear algebra funtions and matrix multiply.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to a static method of ILNumerics.ILMath is made. If no suitable implementation
            is found or cannot be loaded this member will give null.
            <para>Currently, the MKL is used if found.</para><para>This member can be changed, allowing custom implementations of <see cref="T:ILNumerics.Core.Native.ILapack" />, potentially wrapping custom
            native modules.</para><para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="P:ILNumerics.ILMath.FFT">
      <summary>
            FFT implementation, used to compute Fast Fourier Transforms.
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="M:ILNumerics.ILMath.#cctor">
      <summary>
            Main math class providing static builtin functions
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
    <member name="T:ILNumerics_Licensing.ILLicHelper_c83ca19e77db417595acdaab8ab3fff3_">
      <summary>
            This type supports ILNumerics infrastructure. Do not edit the code!
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>This type is automatically generated by ILNumerics Ultimate VS. If you encounter problems compiling this file, make sure to reference ILNumerics.Core in your project!<para>[ILNumerics Computing Engine]</para></remarks>
    </member>
    <member name="M:ILNumerics_Licensing.ILLicHelper_c83ca19e77db417595acdaab8ab3fff3_.#ctor">
      <summary>
            Licensing Helper (internal use)
            <para>[ILNumerics Computing Engine]</para>
      </summary>
      <remarks>
        <para>[ILNumerics Computing Engine]</para>
      </remarks>
    </member>
  </members>
</doc>